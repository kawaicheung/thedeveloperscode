<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>Lessons, advice, and unadulterated opinions on web development - The Developer's
        Code </title>
    <meta name="description" content="50 lessons, words of advice, and unadulterated opinions on web development." />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Language" content="en-us" />
    <meta name="author" content="Ka Wai Cheung" />
    <meta name="copyright" content="Copyright (c) Ka Wai Cheung" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="robots" content="index, follow" />
    <link rel="stylesheet" href="site.css" type="text/css" media="screen" />
    <link rel="stylesheet" href="print.css" type="text/css" media="print" />
</head>
<body> 
    <div id="container">
        <div id="badges">
<!--
            <div id="facebook-badge">
                <div id="fb-root"></div><script src="http://connect.facebook.net/en_US/all.js#xfbml=1"></script><fb:like href="www.thedeveloperscode.com" send="false" layout="box_count" width="50" show_faces="true" font=""></fb:like>
            </div>
            <div id="twitter-badge">    
                <a href="http://twitter.com/share" class="twitter-share-button" data-count="vertical" data-text="Read &quot;The Developer's Code&quot;, 50 lessons, observations & unadulterated opinions on web developer life" data-via="developerscode">Tweet</a><script type="text/javascript" src="http://platform.twitter.com/widgets.js"></script>
            </div>-->
            <div id="twitter-follow">
                <a href="http://www.twitter.com/developerscode"  onclick="_gaq.push(['_trackEvent', 'Meta', 'Twitter Page']);"><img src="http://twitter-badges.s3.amazonaws.com/t_logo-a.png" alt="Follow @developerscode on Twitter" title="Follow @developerscode on Twitter" /></a>
            </div>
            <div id="facebook-follow">
                <a href="http://www.facebook.com/developerscode"  onclick="_gaq.push(['_trackEvent', 'Meta', 'Facebook Page']);"><img src="facebook.jpg" alt="Follow The Developer's Code on Facebook" title="Follow The Developer's Code on Facebook" /></a>
            </div>
            <!--<div id="pdf-icon">
                <a href="http://www.thedeveloperscode.com/TheDevelopersCodeByKaWaiCheung.pdf" onclick="_gaq.push(['_trackEvent', 'Meta', 'Download PDF']);"><img src="pdf-icon.png" alt="PDF of The Developer's Code" title="PDF of The Developer's Code"/></a>
            </div>-->
        </div>
        <div id="controller">
            <div id="prev-controller">
                <a href="#" class="prev-ch-btn">
                    <div class="prev-arrow">Previous Page</div>
                </a>
            </div>
            <div id="next-controller">
                <a href="#" class="next-ch-btn">
                    <div class="next-arrow">Next Page</div>
                </a>
            </div>
        </div>
        <div id="extras">
            <div id="toc">
                <div id="bookdeal">
                    <h5>
                        Need to keep your place?
                    </h5>
		    <p>Click the page margins to bookmark your spot for later.</p>
		    <h5>
			Enjoying the book?
		    </h5>
                    <p>
                        Visit
                        <a href="http://pragprog.com/book/kcdc/the-developer-s-code" onclick="_gaq.push(['_trackEvent', 'Meta', 'Prag Prog']);">The Pragmatic Bookshelf</a>
                        or <a href="http://www.amazon.com/Developers-Code-Ka-Wai-Cheung/dp/1934356794/ref=zg_bs_886498_74" onclick="_gaq.push(['_trackEvent', 'Meta', 'Amazon']);">Amazon</a> for the polished version.
                         Thanks for your support!  
                    </p>
                    </div>
                <ul>
                    <li><a href="#cover">Home</a></li>
                    <li><a href="#backstory">The Backstory</a></li>
                    <li><a href="#tableofcontents">Table of Contents</a></li>
                    <li><a href="#introduction">Introduction</a></li>
                    <li><a href="#metaphor">Metaphor</a></li>
                    <li><a href="#motivation">Motivation</a></li>
                    <li><a href="#productivity">Productivity</a></li>
                    <li><a href="#automation">Automation</a></li>
                    <li><a href="#complexity">Complexity</a></li>
                    <li><a href="#teaching">Teaching</a></li>
                    <li><a href="#clients">Clients</a></li>
                    <li><a href="#pride">Pride</a></li>
                </ul>
                <h5 id="bookmark-note">
                    <strong>Tip:</strong> Leave a bookmark by clicking on the left or right margin of the page.
                </h5>
            </div>
        </div>
        <div id="loader">
        </div>
        <div id="bookmark">
        </div>
        <div id="temp-bookmark">
        </div>
        <div id="cover-return">
            <a href="#" class="btn-return">Continue where I left off...</a></div>
        <div id="cover" class="content">
            <h1>
                The<br />
                Developer&rsquo;s<br />
                &lt;code&gt;</h1>
            <div class="caption">
                50 lessons, observations, & unadulterated opinions on web developer life through the eyes of one of them.
            </div>
            <div class="author">
                KA WAI CHEUNG<br />
<em>of</em> <a href="http://www.wearemammoth.com" onclick="_gaq.push(['_trackEvent', 'Meta', 'WAM Page']);">WE ARE MAMMOTH</a></div>
        </div>
        
        <div class="content">
            <h2 id="backstory">
            The Backstory
            </h2>
            <p>
                In the Fall of 2010, with about 90% of the content complete, 
                I began to pitch this book to several tech publishers.  While I received some great feedback,
                I wasn't able to land a book deal.  The prevailing argument was that this book <em>simply wouldn't sell</em>.
            </p>
            <p>
                One of the best bits of feedback I received was from an editor at O'Reilly, who suggested I
                publish the book online instead and gain an audience that way.  So, I spent the next several months
                completing the material and creating the website you're looking at right now.  It was a great
                way for me to play around with a few features like pagination and bookmarking (you can tap the
                margins to create a bookmark).
            </p>
            <p>
                In June of 2011, this book became a top link on Reddit.  On June 16th, I received over 12,000 hits to 
                the book and over 32,000 hits for the entire month of June.
            </p>
            <p>
                Around the same time, I received an offer from Andy Hunt 
                to refine and re-publish <em>The Developer's Code</em> through <a href="http://www.pragprog.com">The 
                Pragmatic Bookshelf</a>.  I jumped at the opportunity.
            </p>
            <p>
                For the latter half of 2011, I've been working closely with the tremendous team at The Pragmatic Bookshelf
                on a revised and, in my opinion, much more polished book entitled <a href="http://pragprog.com/book/kcdc/the-developer-s-code" onclick="_gaq.push(['_trackEvent', 'Meta', 'Prag Prog']);">The Developer's Code: What Real Programmers Do.</a>
            </p>
            <div class="cartoon">
                <a href="http://pragprog.com/book/kcdc/the-developer-s-code" onclick="_gaq.push(['_trackEvent', 'Meta', 'Prag Prog Book Image']);"><img src="/pragprog_bookcover.jpg" width="300" height="450" /></a>
            </div>
            <p>
                It is currently available as a beta release at 
                <a href="http://pragprog.com/book/kcdc/the-developer-s-code" onclick="_gaq.push(['_trackEvent', 'Meta', 'Prag Prog']);">The Pragmatic Bookshelf</a>
                and on <a href="http://www.amazon.com/Developers-Code-Ka-Wai-Cheung/dp/1934356794/ref=zg_bs_886498_74" onclick="_gaq.push(['_trackEvent', 'Meta', 'Amazon']);">Amazon</a>.  
                If you like what you're reading here, I hope you'll consider purchasing the revised edition.  
                It's a chance for you to prove the publishing industry wrong!  
            </p>
            <p>
                I sincerely hope you enjoy the book.  Thanks for taking the time to read it.
            </p>
        </div>
        <div id="main-toc" class="content">
            <h2 id="tableofcontents">
                Table of Contents</h2>
            <ul>
                <li><a href="#introduction">Introduction</a>
                    <ul>
                    </ul>
                </li>
                <li><a href="#metaphor">Metaphor</a>
                    <ul>
                        <li><a href="#lesson-1">#1: Be wary of metaphors in web development</a></li>
                        <li><a href="#lesson-2">#2: Plan <em>enough</em>, then build</a></li>
                        <li><a href="#lesson-3">#3: Understand launch and Version 2.0</a></li>
                        <li><a href="#lesson-4">#4: The "Ivory Tower" Architect is a myth</a></li>
                        <li><a href="#lesson-5">#5: Specialization isn't mandatory</a></li>
                        <li><a href="#lesson-6">#6: Metaphors can hurt both ways</a></li>
                    </ul>
                </li>
                <li><a href="#motivation">Motivation</a>
                    <ul>
                        <li><a href="#lesson-7">#7: Motivation starts with the opportunity to build something
                            well</a></li>
                        <li><a href="#lesson-8">#8: Begin where you love to begin</a></li>
                        <li><a href="#lesson-9">#9: Be imperfect</a></li>
                        <li><a href="#lesson-10">#10: Stop programming</a></li>
                        <li><a href="#lesson-11">#11: Test your work first thing in the morning</a></li>
                        <li><a href="#lesson-12">#12: Don't work in your bedroom</a></li>
                        <li><a href="#lesson-13">#13: Don't let bad first impressions of your work unravel you</a></li>
                        <li><a href="#lesson-14">#14: Never underestimate the emotional value of finishing</a></li>
                    </ul>
                </li>
                <li><a href="#productivity">Productivity</a>
                    <ul>
                        <li><a href="#lesson-15">#15: Just say "no" to the pet project</a></li>
                        <li><a href="#lesson-16">#16: Set a deadline, even if it's arbitrary</a></li>
                        <li><a href="#lesson-17">#17: Constrain your parameters</a></li>
                        <li><a href="#lesson-18">#18: Cut the detail out of the timeline</a></li>
                        <li><a href="#lesson-19">#19: Make your product better in two ways everyday</a></li>
                        <li><a href="#lesson-20">#20: Invest in good hardware</a></li>
                        <li><a href="#lesson-21">#21: Establish "off-time" and let your co-workers do so too</a></li>
                        <li><a href="#lesson-22">#22: Keep a personal to-do list</a></li>
                        <li><a href="#lesson-23">#23: Write code as a last resort</a></li>
                    </ul>
                </li>
                <li><a href="#automation">Automation</a>
                    <ul>
                        <li><a href="#lesson-24">#24: Separate human work from robot work</a></li>
                        <li><a href="#lesson-25">#25: Take advantage of a machine's strengths</a></li>
                        <li><a href="#lesson-26">#26: Think automation</a></li>
                        <li><a href="#lesson-27">#27: Know the ingredients of a good code generator</a></li>
                        <li><a href="#lesson-28">#28: Avoid touching generated code with bare hands</a></li>
                        <li><a href="#lesson-29">#29: Writing a code generator makes you a better programmer</a></li>
                        <li><a href="#lesson-30">#30: Speak, think, and write code in a ubiquitous language</a></li>
                        <li><a href="#lesson-31">#31: Generated code makes errors obvious and small modifications
                            powerful</a></li>
                        <li><a href="#lesson-32">#32: Address the naysayers</a></li>
                        <li><a href="#lesson-33">#33: Automating software is not like fast-food</a></li>
                    </ul>
                </li>
                <li><a href="#complexity">Complexity</a>
                    <ul>
                        <li><a href="#lesson-34">#34: Snuffing out bad complexity</a></li>
                        <li><a href="#lesson-35">#35: The simplicity paradox</a></li>
                        <li><a href="#lesson-36">#36: Complexity as a game of pick-up sticks</a></li>
                        <li><a href="#lesson-37">#37: Complexity underneath the surface != Complexity at the surface</a></li>
                        <li><a href="#lesson-38">#38: Hard to code might mean hard to use</a></li>
                        <li><a href="#lesson-39">#39: Design patterns and the danger of anticipation</a></li>
                        <li><a href="#lesson-40">#40: Programming Cadence</a></li>
                    </ul>
                </li>
                <li><a href="#teaching">Teaching</a>
                    <ul>
                        <li><a href="#lesson-41">#41: An expert coder doth not an expert teacher make</a></li>
                        <li><a href="#lesson-42">#42: Prevent the "Curse of Knowledge" from creeping into your teaching</a></li>
                        <li><a href="#lesson-43">#43: Teach with obvious examples</a></li>
                        <li><a href="#lesson-44">#44: In the beginning, go for blanket statements over the truth</a></li>
                        <li><a href="#lesson-45">#45: Encourage autonomous thought</a></li>
                    </ul>
                </li>
                <li><a href="#complexity">Clients</a>
                    <ul>
                        <li><a href="#lesson-46">#46: Difficult clients are not uniquely our problem</a></li>
                        <li><a href="#lesson-47">#47: Teach clients what programming actually is</a></li>
                        <li><a href="#lesson-48">#48: Define the goals of your application, seriously</a></li>
                        <li><a href="#lesson-49">#49: Make your work interesting</a></li>
                        <li><a href="#lesson-50">#50: Be forgiving and personable</a></li>
                    </ul>
                </li>
                <li><a href="#pride">Pride</a>
                    <ul>
                        <li><a href="#lesson-52">We have a marketing problem</a></li>
                        <li><a href="#lesson-53">Lessons from the cooking industry</a></li>
                    </ul>
                </li>
            </ul>
        </div>
        <div class="content">
            <h2 id="introduction">
                Introduction
            </h2>
            <p>
                This year (2011), I turn thirty-two. By year's end, I will have been involved in the web
                development industry for over 40% of my life. It's been an awfully fast 40%.
            </p>
            <p>
                When I started college in 1997, campus-wide <em>high-speed Ethernet</em> had just been
                installed across the campus. You plugged a T1 cord into your rather large desktop
                to log on to the WWW. Cell phones were a fashion statement.
                "Text" wasn't a verb. We left phone messages on answering machines. We still wrote
                most things down by hand...with a pen...in a notebook. We brought our CDs with us from home. Social
                networking still meant going out to a frat party, striking out with a few girls,
                and passing out on the front lawn.
            </p>
            <p>
                Today's twenty-five year old entered college with a cell phone that was used primarily
                for calling, and left with one that let her answer calls, play music, write emails,
                read articles, and, most importantly, make farts. There's an app for that.
            </p>
            <p>
                And pity today's poor twenty year old. She is currently spending more time (I mean
                <em>way</em> more time) chatting with friends on her laptop, phone, or iPad than
                together, at some real, physical place in the world. I recently peeked at my younger
                cousin's Facebook news feed. It looked more like a New York Stock Exchange ticker.
            </p>
            <p>
                Society and culture is changing because the web is changing. Browser-based, mobile-based,
                and tablet-based apps, built by people like us are rewriting our rules of 
                engagement and our societal ethos on the order of months, not decades.
            </p>
            <p>
                And if society is morphing this rapidly because of the things we are making, it certainly
                has changed our very own jobs as web professionals. But, when you're in the middle
                of experiencing it, as you and I are, right this very moment, it's hard to gauge how fast 
                change is happening.
            </p>
            <h4>This book is that gauge</h4>
            <p>
                My name is Ka Wai Cheung.  I'm a web programmer, designer, author, blogger, speaker, and founding partner at 
                <a href="http://www.wearemammoth.com">We Are Mammoth</a> in Chicago.  We build applications for some of the
                world's best known companies, and create some of our own <a href="http://www.getdonedone.com">web-based software</a>.  
                You'll hear a bit more about those later.
            </p>
            <p>
                This book is my gauge &mdash; a collection of lessons, advice, and opinions I've developed over the past decade in
                web development &mdash; from dot-com startup intern, to corporate developer, to tech author, to my current post
                at <a href="http://www.wearemammoth.com">We Are Mammoth</a>.  I hope you'll make it yours too.
            </p>
            <p>
                When I first started designing web sites as a summer intern at a .com startup in
                1999, I had no clue how to go about all the intricate aspects of daily life as a
                programmer/designer.  I didn't really know what the questions were.
            </p>
            <p>
                Over the next decade, I'd encounter a plethora of them.  Here's a sample:
            </p>
            <ul>
                <li>Aren't we all getting rich by coming up with a half-baked idea, finding some VC
                    funding, going public, and having an exit strategy?</li>
                <li>What technologies should I be using?</li>
                <li>What makes me more happy, a bigger paycheck or a better way to work?</li>
                <li>How long do we have to keep wireframing before we can start coding?</li>
                <li>When is coding a bad thing?</li>
                <li>How do I convince a client that they're wrong, and I'm right?</li>
            </ul>
            <p>
                No one had these answers written in stone in 1999, or 2005, or even today. Just
                like HTML markup and programming frameworks have evolved on-the-fly over the last
                15 years and are continuing to change with the times, so too are the rules we've
                made for thriving in the industry.
            </p>
            <h4>Why I wrote this book</h4>
            <p>
                And, that's why I wrote this book &mdash; to paint the real picture, both to ourselves
                and to everyone outside the world of web development, to what this job is really
                about.
            </p>
            <p>
                This is a book for software developers of all kinds, tailored to those of us building
                web-based applications. But, it has little to do with code. It doesn't matter if
                you program in C# or Ruby or Python or PHP or Java or JavaScript or ActionScript.
                It doesn't matter whether you're working on databases, server-side code or scripting
                the interface. This book is about everything that surrounds the professional web
                developer. These are topics that aren't just bound to class definitions, interfaces,
                and objects.
            </p>
            <p>
                At the same time, there will be <em>some</em> talk about code. But, when I do talk
                about code, I'll be approaching it in a less technical, and a far more holistic
                way. You won't find a laundry list of best practices or design patterns. There are
                plenty of books that do a great job of this, and I'll mention a few along the way.
            </p>
            <p>
                This book is about what makes our jobs difficult yet rewarding, when things go wrong
                or right, and what makes us tick. It's about why our industry is in constant flux,
                how to maintain motivation, using code to make our lives easier, understanding why
                things become complex, and becoming a better teacher. This book is about how a web
                developer should and shouldn't approach the craft of building web applications.
            </p>
            <p>
                This book is about <em>us</em>. I hope it makes you think about, question, and conquer
                the world of web development a little bit better.
            </p>
           
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a> 
            </div>
        <div class="content">
            <h2 id="metaphor">
                Metaphor</h2>
            <p>
                A web programmer <em>programs</em>, and a web designer <em>designs</em>.  This is what we do.  
                But what does that really mean? There are no reality TV shows, movies, or 
                public interest stories that showcase how we really work. So, when
                I'm asked what I do, I often resort to analogy. Our industry is chock full
                of them. It's the way we describe our work to everyone else.
            </p>
            <p>
                A chef doesn't have to come up with metaphors for cooking. A musician doesn't have
                to describe songs in some roundabout way. People get it. They are self-describing forms of work.
                Pipefitters and bricklayers have the job description succinctly written right
                in their names.  
            </p>
            <p>
                Perhaps it's because programming is just not common knowledge. 
                The average person can't see what makes code elegant or unorganized. A broth is too 
                salty because you can taste it; a melody
                too cliché because you've heard the same rhythm before. These things are easier
                to comprehend than things like poor encapsulation, memory leaks, or scalability.
            </p>
            <p>
               Our medium, even dating back to the first computers, is <em>very</em> new. Humans have been cooking, drawing, dancing, and
                building for thousands of years. Archaeologists have yet to discover those cave paintings of
                <em>Man At His Desk Typing</em>, just yet.
            </p>
            <p>
                So, metaphor has to become our meta-language. Not only is it how we connect
                the uniqueness of programming to the general public, but it's often how we make
                decisions on how to approach software problems.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-1">#1: Be wary of metaphors in web development</h3>
            <p>
                And this is where things get dangerous.
            </p>
            <p>
                <em>Metaphor can make us value things that aren't that important, and undervalue the things
                    that are</em>. 
                Metaphors are like your in-laws: Learn from them, but be wary of them.
            </p>
            <p>
                Sometimes, the line between analogy and reality blurs. When we take these
                comparisons too far, we don't make our best decisions. Metaphor has a devilish way of blinding
                us from the truth. Our decisions might make perfect sense in the context of the metaphor,
                but when you strip it down to just the business of building applications, you can easily be
                led astray. We sometimes rely on the perceived benefits of the metaphor too heavily
                rather than paying attention to the reality of the situation.
            </p>
            <p>
                For instance, we often use traditional architecture as a metaphor for building
                software. It's the origin of most of our organizational titles. That's why we call ourselves 
                <em>software architects</em>, <em>information architects</em>, <em>senior developers</em>,
                <em>junior developers</em>, and <em>project managers</em>. That's why many of us still swear by wireframes,
                specifications, workflow diagrams, Gantt charts, and waterfall development. We've
                built a large portion of the software development process by piggybacking off of
                another industry.
            </p>
            <p>
                These concepts are essential in another medium and they have <em>some</em> merit in our world as
                well. But, they can just as easily imprison us. If you've ever stopped to think
                about why you approach a problem a certain way, you might be able to trace it back to
                following the metaphor of traditional architecture (or another metaphor) too closely.
            </p>
            <p>
                So, how has metaphor hurt us? Let's look at a few examples where we've stretched a concept
                from real architecture into a less-than-ideal fit for software.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-2">
                #2: Plan <em>enough</em>, then build</h3>
            <p>
                In traditional architecture, planning is essential. Certain things unequivocally have to happen
                before others. Studs go in before plumbing, plumbing before walls, walls before
                paint. <span class="code">Undo</span>, <span class="code">Cut</span>, or <span class="code">Revert</span> aren't viable options 
                when you build a library, baseball stadium, or a skyscraper.  
            </p>
            <p>
                The software <span class="code">Undo</span> is <span class="code">CTRL + Z</span>. The software <span class="code">Cut</span> is <span class="code">CTRL + X</span>.
                The software <span class="code">Revert</span> is a code rollback in source control. 
            </p>
            <div class="cartoon">
                <img src="http://www.andertoons.com/img/cartoons/5507.jpg"/>
            </div>
            <p>
                That's why buildings require specs, blueprints, and CAD drawings. In a traditional architect's dream world, 
                materials would be infinitely available, a life-size model of a building could be risen
                in a week, and a to-scale suspension bridge stress-tested in a few days.
                If architects could instantaneously replicate a 
                building to ten new lots at once, I'd imagine they would consider letting go of all the formalities of documentation.
            </p>
            <p>
                Of course, all this is mere fantasy. So, writing detailed specifications in excruciating detail
                makes the most sense when you've decided to build a skyscraper.
            </p>
            <p>
                On the other hand, these <em>are</em> the luxuries of our industry. Software components
                don't need to wait on a shipment of letters and numbers from the factory. You type, compile,
                test, and repeat. We can write and test code on what will become the real product &mdash; not some model of the
                real product. We have the luxury of
                watching our suspension bridges break hundreds of times while in development, in all different places,
                under all different conditions without the worry of wasting materials or putting
                people's lives in jeopardy. Working this way is completely feasible.
            </p>
            <p>
                When we finish software, the exact same application
                can be shipped, sent, deleted, copied, and re-copied a thousand times with negligible
                human effort. When the developers of the Wynn Hotel in Las Vegas built a virtually
                identical twin hotel called the Encore in 2008, they didn't have the luxury of copying
                and pasting the 2005 version over into the vacant lot. They had to start with specs
                and planning even to build a nearly identical structure over again.
            </p>
            <p>
                Even when software meant shipping floppy disks and
                CDs, planning extensively still made a lot of sense. But, web-based software is
                a different game. Specs, wireframes, detailed information architecture, and complete
                planning prior to writing a line of code still has merit, but it doesn't fully take
                advantage of the medium. For instance, we can release new builds daily or hourly &mdash; whenever
                we want, with very low overhead, from the comfort of our cushy Aeron chairs.
            </p>
            <p>
                The "plan, plan, plan" metaphor overvalues the time we spend trying to get everything
                perfect, and undervalues the time we could be spending writing code, building, and
                iterating as we go.
            </p>
            <p>
                Only recently has iteration, starting with code, and working without strict functional
                specs become more widely accepted. Agile development is not revolutionary &mdash; it's
                just untying us from a metaphor that doesn't make as much sense today as it did in the past.
            </p>
            <p>
                That's not to say that traditional waterfall development is obselete.  It still has its merits on 
                many software projects in large organizations. But following that metaphor completely blind 
                might also blind us from an approach that better fits the medium we work in.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-3">
                #3: Understand launch and Version 2.0</h3>
            <p>
                Traditionally, we've approached a launch date as a mission critical point in time when software must
                be <em>final</em>. 
            </p>
            <p>
                For buildings and structures, it's essential.  At one time, the metaphor made sense in software too. 
                When we shipped software on floppy disks and CDs, things had to be just right. There
                were huge cost and time implications for bugs. Projects were delayed for the sake
                of getting it perfect, or for the sake of shoving in a new feature. I'll talk about
                what that does for morale in the next chapter.
            </p>
            <p>
                Today, web-based applications aren't launched &mdash; they're
                uploaded, released, and pushed. Software lives and matures over time. 
            </p>
            <p>
                And, once we've launched, iteration #2, #3, and #4 can come a few days or even hours
                later. Even the concept of formal version releases of software is antiquated. It
                made sense in the bygone days of shipping software on disk.
            </p>
            <p>
                On the web, we continuously integrate and constantly iterate. Unlike
                the auto industry or food industry, there's no need for mass "recall." Today, a critical
                bug can be patched, tested, and deployed immediately. It's not version 2.0 anymore.
                It's version 2.0.12931.  Or, it's simply <em>today's</em> version. Is anyone in the public eye 
                really keeping track anymore? 
            </p>
            <p>
                Society is growing accustomed to iteration too.  Did you see the new image gallery on Facebook?
                Did you see Google's new auto-suggest feature?  Did you see Twitter's new layout?  Nobody 
                warned us with a month-long advertising campaign.  New changes just <em>appear</em> now.
            </p>
            <p>
                IMVU (<a href="http://www.imvu.com">http://www.imvu.com</a>), a popular 3D-chat
                application boasts over 100 million registered users, and they ship releases 20
                times <em>a day</em>.
            </p>
            <p>
                In today's landscape, the initial launch shouldn't feel like the end-all-be-all like it once did, or
                still does in many other industries.
                It's just one of hundreds (if not thousands) of mini-launches that take
                place during the lifespan of software. Keeping that perspective can relieve the
                mental pressure of launching software.
            </p>
            <p>
                This mentality can be easily abused.  Don't use this change of construct as an excuse for being lazy or 
                leaving loose ends untied.
                The launch of any web app should be very, very good before others
                have at it. The big things need to be right. Proper security needs to be in place.  But, the small
                stuff, the ones that are OK to fix afterward, shouldn't keep you from releasing software.  You'll be surprised how often
                things you thought were important when you launch suddenly aren't now that it's out there.
            </p>
            <p>
                And, you still ought to celebrate when software launches. Grab a drink, make a toast,
                and take your team out to a fancy dinner.  But, don't spend all your emotional currency
                on just the wedding. There's an entire relationship you'll have with software afterwards.
                There's time to make adjustments, add in a family of new features, and right wrongs.
            </p>
            <p>
                Launch is just another pinpoint in software's life. Not the end-all-be-all.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-4">
                #4: The "Ivory Tower" Architect is a myth</h3>
            <p>
                I've never liked the idea that technical architects should stop coding.
            </p>
            <p>
                In physical architecture, architects perch in an ivory tower, living in a world of only planning. They don't
                nail, drill, paint, or solder. Requiring architects to do the physical work of drilling holes and laying
                concrete is simply impractical.  Architecting and developing are two distinct career tracks.
            </p>
            <p>
                In our industry, you work your way up to the role of a technical architect by actually developing &mdash; by 
                doing the "physical" work of building applications. But, as you move up the software development
                ladder, you typically write less code. You immerse yourself more with planning than
                with discovering the problems on the front-line. You concern yourself more about an overall vision and less
                about the intimate details of code. As an industry, we've really latched on to the metaphor
                that architects should plan, and developers should develop.
            </p>
            <p>
                This creates a false perception that once you've reached a certain level, programming
                is no longer where you're most valuable. Leave the dirty work for the junior developers.
                At the same time, it pushes lower-level programmers away from thinking about the
                overall goals and direction of the project. Just concentrate on implementation. The architect-developer model makes
                both parties less accountable for the application as a whole.
            </p>
            <p>
                When you split up roles into the somewhat arbitrary hierarchy of those that think
                about the technical "big picture" and those that only think in <span class="code">if</span> statements,
                <span class="code">for</span> loops, and markup, you fracture disciplines that really belong together.
            </p>
            <p>
                Pure technical architects can make a guess at the best architecture, the best design
                pattern or the best practice. But, it's only when you're knee-deep in code that
                you discover where the real challenges exist. At the same time, the developer
                who isn't given the reigns to think high-level also doesn't get the chance to voice
                a second opinion. Often, it's the guy who's doing the actual work that can see the
                bumps ahead.
            </p>
            <p>
                We've taken the architect-developer analogy too far. The corporate ladder in the
                software industry needs a better analogy.
            </p>
            <p>
                To build a building, architects architect and developers develop. Traditional architects
                know how to create elaborate plans and specs in fine detail. But, they don't build.
                It's simply not reasonable. The separation between those that think high-level and
                those that work in the trenches is largely for practical reasons.
            </p>
            <p>
                In software, it doesn't have to be that way. Great developers can be both "in
                the trenches" and "high-level" at the same time. Compared to developers, an architect
                might spend the most time thinking high-level, but she ought to have a foot in development.
            </p>
            <h4>And another thing...</h4>
            <p>
                And when was it decided that programmers have to be social outcasts? Sometimes,
                a developer is best equipped to explain to a client why a feature won't help or
                would put the project over budget. Project managers aren't the only people that
                ought to communicate to stakeholders.
            </p>
            <p>
                For software to really succeed, I'd rather have a group of developers that are capable
                of coming up with a plan, executing, and then communicating than a group of people
                that <em>only</em> plan, <em>only</em> execute, or <em>only</em> communicate.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-5">
                #5: Specialization isn't mandatory</h3>
            <p>
                Be wary about creating hard lines across expertise within a development
                team. In traditional architecture, it's not practical for the electrician to
                also be the cement pourer, the brick layer, and the painter. They are specialties
                in and of themselves. They also occur in physically different places. You need to
                have a group of specialized doers honing each craft separately for intellectual
                and practical reasons.
            </p>
            <p>
                In software, you can be a designer, programmer, and DBA. You can be well-versed
                in Oracle, SQLServer, PHP, Java, .NET, C++, Python, and SQL while knowing your way
                around HTML, CSS, JavaScript and Flash. Why is this not only possible, but practical?
            </p>
            <p>
                First, all of these toolsets live on the screen right in front of you. If you're
                currently working in SQL, you don't have to go somewhere else to write HTML, or to cut an image
                in Photoshop. You switch programs on your computer. There is no physical barrier between any programming
                disciplines.
            </p>
            <p>
                In addition, software concepts tend to transcend language or tier. MVC (model-view-controller)
                is an application architecture adopted in many UI platform applications, like Adobe Flex's Cairngorm platform, along with
                many server-side development frameworks, like .NET. Programming languages today have
                an extraordinary amount of overlap. Design patterns and refactoring are concepts
                that live everywhere in the programming landscape.
            </p>
            <p>
                At <a href="http://www.wearemammoth.com">We Are Mammoth</a>, most of our development team knows multiple programming languages
                and splits time between front-end, middleware, and database work. It helps us even
                out everyone's workload because we're all adept at working on all layers of an application.
            </p>
            <p>
                A .NET developer, a strict-standards HTML whizkid, and a data modeling expert can
                all live within the same person. You may have an expertise and interest in one or
                the other, but there's no reason you can't be great at many disciplines.
            </p>
            <div class="cartoon">
                <img src="http://www.andertoons.com/img/cartoons/6254.jpg"/>
            </div>
            <p>
                Even further, why can't great programmers also be great user interface designers
                also? All too often I hear a programmer instantly denounce even the possibility
                that he could also be a great visual designer.
            </p>
            <p>
                Conceptually, designing user interfaces is not that far off the map from designing
                a sound software architecture. Great functional UI is about clear affordances, organization,
                scalability, and intention. It has many of the same qualities we cherish in software
                design.
            </p>
            <p>
                The reverse is true too. Too few talented user interface designers consider themselves
                capable of becoming great programmers. Perhaps programmers look at user interface
                design as making things "pretty" and designers look at programming as writing a
                lot of "technical stuff."
            </p>
            <p>
                But, in the end, the goals of software design from both the interface level and
                the engine are the same.  There is no reason why we can't be great at multiple disciplines.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-6">
                #6: Metaphors can hurt both ways</h3>
            <p>
                You've seen why metaphors can hurt how we approach software. When we take them too
                far, we develop habits built around false pretenses. Not only do metaphors make us do 
                things less efficiently, but they keep us
                from thinking about <em>better ways</em> of doing things.
            </p>
            <p>
                Wireframes and detailed specifications take away time from building and reviewing
                the real thing. It doesn't take advantage of the opportunities to iterate and refactor.
                It makes us think through the entire process of writing code without actually having written any
                code yet.
            </p>
            <p>
                The over-emphasis on launch hides the fact that software today can be modified and
                redistributed with relative ease. We don't "ship" software anymore. We upload and
                download it off the internet, or the software itself is entirely web-based. When
                launch dates get pushed back because features absolutely need to be crammed in,
                developer morale suffers. It's a complete buzzkill for a development team.
            </p>
            <p>
                The traditional roles in software development, between architects, developers, and
                project managers, inhibit those that have talents in multiple areas. You can be
                a great visionary, a thoughtful programmer, and clear communicator at the same time.
                Following the metaphor too closely inhibits really talented people from all the
                opportunities this industry provides.
            </p>
            <h4>
                A search for new metaphors</h4>
            <p>
                Building software isn't like building a building, or sending a rocket into outer
                space. What we do is more like writing a novel or music. Consider how 
                these kinds of professionals "plan" their work. 
            </p>
            <p>
                If you're an author, you
                might write a chapter outline to get a general guideline of what you want to write about.
                But after that, you start writing the real thing.  Then you edit, and repeat. A word change here or an entire
                chapter removed there. Writing is a lot more like how we program.
            </p>
            <p>
                A musician doesn't write out sheet music for months, and then hope the notes sound
                right. He plays and plays, and finds a riff or a hook that works. He might have
                a few lines of lyrics and then finds the right chords around it or vice-versa. He
                builds the song in pieces and tests it out in pieces.
            </p>
            <p>
                In both cases, the cost of materials is cheap. Paper and pen are readily available.
                Guitars don't get paid by the note. Sound is cheap. Just the same, code is our own cheap material.
                Once you've got your development environment setup, there is no material cost of
                writing code.
            </p>
            <h4>
                No metaphor at all</h4>
            <p>
                Metaphors have a place in the beginning. They offer a stake in the ground when you're
                not sure how to approach a software problem or when there's not enough information
                to make sound decisions. But, once you've run with the metaphor for awhile, see
                where it's helping <em>and</em> where it's actually hurting you.
            </p>
            <p>
                Identify the rules that persist solely to maintain the essence of the metaphor,
                and shed them once you've found a better way of doing your work. The best approach
                to building software might be not having a metaphor to lean on at all.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h2 id="motivation">
                Motivation</h2>
            <p>
                Regardless of how skilled you are, if you're not motivated to write code, get out.
                Accountants might get through writing a spreadsheet just fine without motivation;
                a cashier can get by his day without passion. But, unmotivated developers kill a
                software project.
            </p>
            <p>
                Motivation must be sustainable. It must be unearthed and cultivated continuously
                throughout development. What keeps you coding with passion at the beginning of a
                project might not be your source of inspiration at the finish line. Different things
                can get you going at different points in the process of building software.
            </p>
            <p>
                Sustaining motivation isn't unique to software.  You see it all the time in the media.
                The star athlete who signed the big multi-million dollar contract now doesn't give
                his full effort during a game.  The band we grew up loving now starts "cashing it
                in" by churning out mediocre albums.  Many athletes, musicians, and artists burn
                out even with the guarantee of wealth.  It's proof that one thing alone isn't enough
                to <em>sustain</em> motivation.
            </p>
            <p>
                You need different ways to keep passion running through your veins.  A food critic's
                review keeps a chef on her toes.  But so does a busy restaurant, a happy staff, a
                quality set of knives, and a steady supply of fresh ingredients.  Motivating yourself
                to run a restaurant comes from all different kinds of sources.  So does building
                software.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-7">
                #7: Motivation starts with the opportunity to build something well</h3>
            <p>
                In this industry, long-lasting motivation lives not in a big salary, a bonus, a
                free lunch, or a ping-pong or pool table. Long-lasting motivation comes from the
                <em>work you do</em>. Every passionate programmer I've ever met is far more excited
                to tell me about an elegant solution to some technical problem they've spent hours
                agonizing over than that 10% raise they just received at their corporate coding gig.
            </p>
            <p>
                That's why I'm baffled when, time after time, code-geeks, especially the young, carefree
                ones that only have rent to pay, settle for that
                new, yet completely uninspiring gig with the slightly larger salary and the promise
                of a bigger bonus.
            </p>
            <div class="cartoon">
                <img src="http://www.andertoons.com/img/cartoons/6110.jpg"/>
            </div>
            <p>
                If you fit that mold, and the difference between salary <span class="code">X</span> and 
                salary <span class="code">X * 1.05</span> is
                really the difference between a few more wild nights out on the town a year, go
                for the gig with the more interesting problems, with the more impassioned and driven
                employees, with the better software and hardware.  Most importantly, go where the
                things being built are at the center of everyone's concern. Go
                where you have a chance to <em>build something well</em>.  It's an investment in passion,
                happiness, and fulfilliment. 
            </p>
            <p>
                Don't stick around at the corporate gig you hate just because they're luring you with more cash.  
                Leave that kind of job mentality to people who actually have horrible jobs &mdash; you know,
                accountants, lawyers, and members of the L.A. Clippers.
            </p>
            <p>
                For me, it doesn't matter all-that-much what I'm building. It could be a one page website, a search engine,
                an online rolodex, an interactive map, or a game. It could be used by millions or
                thousands or eight people. It could be a 6-month build or a 2-hour exercise. I could
                be mostly writing markup, working on UI, writing server-side code, or building a
                database.
            </p>
            <p>
                I'm gung-ho about my work when I know that I have a chance to <em>build something well</em>.
            </p>
            <p>
                What gives me that chance? Projects that have distinct goals. Projects that have all the pieces either in
                place, or a plan to get them in place. Projects as ambitious as they are
                thought through. Projects that have a defined time to deliver.
                These kinds of projects give my work a purpose.
            </p>
            <p>
                What projects make building something well harder to do? Projects that aren't
                well-defined. Projects whose conception is missing too many pieces. Projects mired
                with great ambition but devoid of forethought. Projects that have little, or even
                worse, a false sense of urgency.
            </p>
            <p>
                I can look at the hundreds of programming projects I've worked on in the first dozen
                years of my programming career. All the great ones had those motivating qualities.
                All the poor ones didn't. Find the gigs that handle projects in a way that gives
                you the chance to succeed and feel great about your work. The residual perks will
                come a far second.
            </p>
            <p>
                There's a great TED talk given by New York Times best-selling author, Dan Pink,
                on the surprising science of motivation* (<a href="http://www.ted.com/talks/dan_pink_on_motivation.html">You can watch it here</a>).
                He argues that traditional motivational factors in business (the raise, the perk,
                or the bonus) do work – but only on trivial matters – the kind of tasks that are
                simple and directed.
            </p>
            <p>
                In contrast, tasks that involved critical analysis and creative problem-solving,
                like the ones that we face every day, weren't aided by dangling a monetary carrot
                over someone's head. In fact, there was an inverse correlation between monetary
                incentive and performance &mdash; the greater the monetary reward, the <em>worse</em>
                they did.
            </p>
            <p>
                When you're choosing that next gig, remember what really keeps you motivated for
                the long haul. It isn't the external rewards, it's the work itself.
            </p>
            <p class="footnote">
                *- (If you want the long version, read his book <a href="http://www.amazon.com/Drive-Surprising-Truth-About-Motivates/dp/1594488843">Drive: The Surprising Truth about
                what Motivates Us</a>).
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-8">
                #8: Begin where you love to begin</h3>
            <p>
                Sometimes the hardest place to find motivation is the very start. Thinking about
                code is easy. Code always compiles perfectly in your head. You don't obsess over
                the hundreds of minor obstacles you'll face along the way. But, once you commit
                to actually writing code, the game changes.
            </p>
            <p>
                It's not too different from writing this book. I spent far more time thinking about
                what I wanted to write about than actually writing. Writing can sometimes be a soul-sucking
                game of uninspired lines, mental blocks, and distractive internet surfing.
            </p>
            <p>
                Natalie Goldberg's <a href="http://www.amazon.com/Writing-Down-Bones-Freeing-Writer/dp/0877733759">Writing Down the Bones</a> is an entire book on motivation for
                writers. She offers a simple tip on starting. Instead of focusing on the big opening,
                start writing somewhere in the middle of the story. Begin at the point you're attracted
                to the most. Don't try to write from the very beginning.
            </p>
            <p>
                We spend so much time concerning ourselves with the big, attention-grabbing opener,
                when, in reality, it's a rather insignificant portion of the entire story. There's
                a considerable amount of work after the opening paragraph. That's the approach I
                took for this book. Nothing was written linearly. In the beginning, I focused on
                a specific topic when that topic inspired me.
            </p>
            <p>
                You can apply the same concept to building software. You don't have to start with
                the homepage, or with the database before the business logic. Instead of starting
                software at the beginning, start at the place you're most comfortable or excited
                about. And, keep in mind we have the luxury that other builders don't. Unlike building
                houses, cars, or anything physical, we do not need to start anywhere specific. We
                can always <em>refactor</em> later on. You may take a few circuitous routes, but,
                if they are inspired rather than labored, you'll get more good work done faster.
            </p>
            <p>
                So, if you have the freedom to be greedy about where to start writing software,
                be greedy. Pick a feature you find most interesting and work your way out from there.
            </p>
            <p>
                This is especially helpful when you're about to embark on building a big piece of
                software. Rather than spend three days formulating a timeline and release schedule,
                commit those days working on the part of the application that most interests you.
                A week in, you'll know how much motivation you really have, and you'll have a far
                better idea of when the other parts can fall into place.
            </p>
            <p>
                If you find yourself quickly losing steam, you can cut your losses then. But, more
                often than not, you'll find the daunting task of building software not so insurmountable.
                Three solid days (or a week) of building an application and you'll know a lot more
                about what you're building and how quickly the rest can get done. Putting together
                a realistic timeline is much easier after you've got a bit of work under your belt.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-9">
                #9: Be imperfect</h3>
            <p>
                Every passionate programmer cares, first and foremost, about his code. It's our
                canvas, our playing field, and our stage. While no user will ever look at our code,
                the passionate programmer labors over every line. We care about how our code might
                perform under the most severe of conditions. We make attempts to reduce excess calls
                to the server, to the service, and to the database. Even when we know, full well,
                we're building a small app for a small audience, a lot of us still care our applications
                will perform under the biggest of stages.
            </p>
            <p>
                And yet, to survive in this industry, you better not be a perfectionist. There is
                no such thing as a perfect piece of software – especially web software. Our products
                breathe and live through our users. They morph as our user base grows. Features
                beget new features. Bugs beget new bugs.  Trying to be perfect can be exhausting.
            </p>
            <p>
                The approach you took the first day you wrote the first line of code is likely completely
                different from the approach you're taking today. Software changes over time. You
                build, tweak, iterate, and occasionally have to rewrite. And, you better be OK with
                that.
            </p>
            <p>
                A great software developer is obsessive-compulsive, yet accepts imperfection all
                the time. Trying to write "perfect code" is crippling. The quicker you can accept
                imperfection, the more motivated you'll be to keep moving forward with your work, and the
                more work you'll actually get done.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-10">
                #10: Stop programming</h3>
            <p>
                You probably program too much. 
            </p>
            <p>
                Just when you've really gotten into your work,
                when your brain is entirely wrapped around your code, when your hands, eyes, and
                thoughts are working in harmony, stop. Look up. Think about when you're going to
                finish for the day. Look forward to shutting off your computer. Get outside a little.
            </p>
            <div class="cartoon">
                <img src="http://www.andertoons.com/img/cartoons/6209.jpg"/>
            </div>
            <p>
                Programming, for all its mental exercise, is a very comfortable physical activity.
                We usually program while sitting, and as the hours waste away, sitting lower, and more
                out-of-posture in our chairs. Some of us even eat and drink at our desks, while we code away.
                You can tell just by examining the keyboards &mdash; the somewhat slick ones with a pound of
                crumbs under the keys. 
            </p>
            <p>
                This comfort is dangerous. It means we can do this for hours and hours and hours
                without realizing we've exhausted our own resources. When you've hit that point
                where your code gets a bit sloppy, or better yet, just before it, stop. Great programming
                is about maximizing the amount of time you're working at your best, not the cumulative
                hours you spend in front of a screen.
            </p>
            <p>
                Two hours of quality programming time is better
                than 8 hours of struggle. You're far more susceptible to taking shortcuts or breaking
                standard conventions when you're coding tired. Those extra hours are spent creating
                bad code &mdash; code that you might regret the next day. So, cut your programming time
                down, get outside, and live a little.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-11">
                #11: Test your work first thing in the morning</h3>
            <p>
                Test your software first thing in the morning. It's when you're most fresh and motivated
                to continue building something good.
            </p>
            <p>
                During the day, we spend so much effort building software, that we lose steam testing
                each piece we write. It gets hard to see the big picture as the day wears on. By
                late afternoon, you're too close to the software. Your perception of what makes
                sense or feels right competes with fatigue, disinterest, and hunger.
            </p>
            <p>
                Should this feature be here or there? Should we move this function to another screen?
                Will this make sense? Is this latest tweak really that important? At 5pm, it's hard
                to know what your software feels like because you've been in it for too long.
            </p>
            <p>
                However, at 9am, fresh from a night's sleep, you can usually answer these questions
                better. Your mental cobwebs are gone. Before diving into the build, this is the
                best time to give your software the once-over.
            </p>
            <p>
                In the morning, your software feels new again. You approach it like someone less
                fettered by what's behind the scenes. You can approach it from a less biased viewpoint
                because you've had time away.
            </p>
            <p>
                The morning has a way of making you forget some of the copious details of code you
                may have obsessed about the night before. No longer pre-occupied with the slightly
                inelegant implementation that made something work, your mind is totally devoted
                to what you see in front of you rather than thinking about what's happening underneath.
            </p>
            <p>
                When you test, start from the beginning. Don't dig into a particular section. Just
                experience it again. The night before, you may have been working on a piece of functionality
                that a real user may only use once or twice...or never. In the morning, focus on
                the things most people will use most of the time. It's a much better way to focus
                on the priorities of your software and focus on what needs fixing first.
            </p>
            <p>
                Testing your software in the morning, before adding more code, is a great way to
                make sure you're still making good software. It's when you're most fresh and motivated.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-12">
                #12: Don't work in your bedroom</h3>
            <p>
                If you have the "luxury" of working from home on a consistent basis, the one place
                you should never code is in your bedroom. Or your living room. Have a confined area
                to work, preferably a second room, that you can physically leave from after your
                work is over.
            </p>
            <p>
                Why? Having that separation between work and home is important. As much as you can
                love coding, you need to define a physical boundary between when you are working
                and when you are off doing something else. Otherwise, your work and non-work life
                become physically (and psychologically) the same.
            </p>
            <p>
                Separating the two will keep you fresh and motivated to sit down and get back to
                work again.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-13">
                #13: Don't let bad first impressions of your work unravel you</h3>
            <p>
                As web apps go, how important are users' first impressions?  I don't think they are very important.
            </p>
            <p> No doubt, bad first
                impressions could be a sign that something really is wrong with your software. But,
                there are two things I've learned that account for many bad first impressions.
            </p>
            <h4>
                Sometimes bad first impressions really mean you simply haven't used the software
                before.</h4>
            <p>
                These are the ones we should really take with a grain of salt. For instance, the
                first time I used Gmail, I had to get used to it for a few days.
            </p>
            <p>
                "These emails, they're like [sic] mini-forums. They're like threads of discussion...not
                email. Interesting. Do I like it? No. Yes. I don't know...maybe?"
            </p>
            <p>
                Gmail email threads were novel, if not strange. I heard many people rave about it,
                but I heard many people rip it to shreds. A year later? I stopped hearing about
                it altogether. Here's a typical conversation you might have with someone that uses
                Gmail today:
            </p>
            <blockquote>
                <p>
                    Male in red cap: "Hey dude, do you use Gmail?"
                    <br />
                    Male in blue cap: "Yeah."
                    <br />
                    Male in red cap: "What do you think?"
                    <br />
                    Male in blue cap: "It's fine. Lately it's been slow. Hey let's go grab some beers."
                </p>
            </blockquote>
            <p>
                It turns out that both systems work for me, and these two fine gentlemen above.
                We've stopped obsessing over it. In fact, today, I use both Outlook and Gmail. I
                also know lots of others who use both a non-Gmail email client and Gmail. When I
                use Outlook, I expect normal, old-school email. When I use Gmail, I expect "special-forum-like-email-madness."
                In the end, I'm comfortable with both.
            </p>
            <div class="cartoon">
                <img src="http://www.andertoons.com/img/cartoons/6063.jpg"/>
            </div>
            <p>
                I'll admit it. It takes some huevos to try and redefine paradigms as firmly implanted
                in society as email. In my line of work, fortunately, the stakes are a lot smaller.
                Radio buttons or drop down list? Search box on every page or just some pages? The
                likely answer? Yes. Yes. And Yes. And Yes. In the end, when you are accustomed to
                seeing the same software over and over, there's a good chance you'll get comfortable
                with whatever design decisions you first had a problem with.
            </p>
            <p>
                I hear the naysayers knocking. Users conform to software? Are our reactions to software
                not important? Is this coming from the same guy that helped bring you <a href="http://www.amazon.com/Flash-Application-Design-Solutions-Usability/dp/1590595947">
                Flash Application Design Solutions: The Flash <em>Usability</em> Handbook</a> (purchase it at any of your favorite
                online bookstores!)? Yes it is!
            </p>
            <p>
                I'm not saying that first impressions don't mean anything. But, those initial gut
                reactions to having seen something for the first time are often just that &mdash; gut
                reactions. As users, we're naturally daunted by something new. Yet, too often, as
                developers, we take those initial user reactions too seriously.
            </p>
            <p>
                Here's the other problem:
            </p>
            <h4>
                Sometimes bad first impressions are not indicative of what's really important.</h4>
            <p>
                If Google just opened shop and I was a usability tester, here's what my first impressions
                might be:
            </p>
            <ul>
                <li>The "Google Search" button should flip with "I'm Feeling Lucky" because I'm used
                    to clicking the right-most button when I submit information, and I'm usually going
                    to search rather than "press my luck."</li>
                <li>I don't get what "I'm Feeling Lucky" is. That's confusing. There should be instruction
                    there as to what might happen when I click it.</li>
                <li>You asked me to do an advanced search, and I had to look around a bit to figure
                    out what you meant. Oh, and that advanced search page was hard to use.</li>
                <li>The navigation links at the bottom should be above the search bar, because that's
                    where I'm used to seeing navigation.</li>
            </ul>
            <p>
                Ask me now, and here's my rebuttal to my initial first impressions:
            </p>
            <ul>
                <li>I'm used to that now.</li>
                <li>I get it. I clicked it a few times and now I know it just takes the first search
                    off the list and sends you right there.</li>
                <li>I don't ever do an advanced search. And that link is small so I'm not bothered by
                    it.</li>
                <li>I never use those links, so I'm glad they're underneath the search box.</li>
            </ul>
            <p>
                First impressions are often skewed because we don't really get how we'll ultimately
                conform to the software. Initially, something you think might be important (an advanced
                search option) ends up not being important at all. Something that's a little off from what
                you're accustomed to (those buttons should be reversed), you simply get acclimated to
                after a short period of time.
            </p>
            <p>
                So, when you're confronted with negative feedback from your customers, clients,
                or co-workers, stick to your guns. Explain why you did the things you did. Ask them
                to let your work simmer for a few days or a week. If those problems still persist,
                then, perhaps there really is a flaw in your application. But, you'll be surprised
                how often those initial, instinctual, negative impressions fade away.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-14">
                #14: Never underestimate the emotional value of finishing</h3>
            <p>
                In the previous chapter, I talked about launch. In web development, launch is just
                one of the many events in the lifespan of software. It isn't the end of development,
                it's just another phase. We shouldn't postpone launch to perfect software. But,
                a launch date <em>still</em> keeps us motivated.
            </p>
            <p>
                Why? Because a launch date carries <em>emotional</em> value. Knowing your software
                is no longer waiting on the sidelines, and is alive and ready, is a huge lift to
                the senses. You've <em>finished</em> something.
            </p>
            <p>
                By finished, of course, I just mean software that's built, launched and usable,
                rather than software that's still in the throes of development. Too often, we underestimate
                the emotional value of work that is simply <em>finished</em>.
            </p>
            <p>
                Launch is not an application's end-all final state. Perhaps there are even tectonic
                changes to be made in the future. But the mental uplift of knowing that you've finished
                is often underrated. Launch at the earliest moment you can, when your software is
                good enough to go so you can feel the mental boost.
            </p>
            <p>
                The good feeling of <em>finishing </em>has a huge implication on how well and how
                efficiently you <em>continue</em> to do your work. Contrast that with the unmotivated
                feeling of the endless tweaking of software still not ready for prime-time. That
                has an equally negative impact.
            </p>
            <p>
                While we underestimate the emotional uplift of launch, we overestimate the perceived
                headaches of trying to tweak an application after the fact &mdash; even if they are deep
                changes to functionality.
            </p>
            <p>
                Very few add-ons, removals, or logic shifts are undoable. Good programmers
                prepare themselves for this all the time. The basis of design patterns, methods
                on refactoring, and best practices is largely to accommodate for the very real fact
                that what your code is doing today will likely get tweaked (endlessly) tomorrow.
            </p>
            <p>
                So, get your software to launch as soon as you reasonably can. It's a natural high.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h2 id="productivity">
                Productivity</h2>
            <p>
                Motivation may be what we need to get started. But, productivity is the tangible
                measure of success.  It's an everyday, consistent level of impassioned work.
            </p>
            <p>
                The corporate world, as it does with just about any concept, equates productivity to some calculable metric.  
                In this case, a metric like <em>utilization</em> or <em>throughput</em>. 
                Productivity is often equated to how <em>much</em> work you do or how <em>many</em> things you do at once, 
                not the quality of your work. 
            </p>
            <p> 
                Multi-tasking is the quintessential act for pretending like you're being productive, but rarely a great way to actually do good work.
                "Working" through lunch is one of these acts. How much quality code is really being written typing with one pointer finger while the other hand 
                grips that footlong sandwich?  
            </p>
            <p>
                And, plus, that's not enjoyable.  Leave your desk.  Eat your lunch in peace, and get some fresh air.
                The code will be there when you come back.  And, before you get to that, read my thoughts on really being productive.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-15">
                #15: Just say "no" to the pet project</h3>
            <p>
                Every one of us has a pet project archive. Software you started and saw part of
                the way through, but never quite finished. Code that began strong but came to
                a screeching halt because more pressing issues came up. Other work simply got in
                the way, or, you just lost interest.
            </p>
            <p>
                Pet projects fail when there are no time constraints and nothing's on the line.
                When your launch date is "one of these days" you likely won't be finishing it anytime
                soon.
            </p>
            <p>
                That's why <em>time is the most important parameter in maintaining your passion
                for writing software</em>. With a pet project, it's fine to just start writing code for
                your own enjoyment and learning. But, when you're ready to turn it into something
                real, define your time boundaries. Answer the following.
                It'll turn your project into something real.
            </p>
            <ul>
                <li>How much time will you spend working on your pet project each day and each week?</li>
                <li>What's the first day you can show it to someone else?</li>
                <li>What day do you launch to the public?</li>
                <li>What day will you release your first major iteration?</li>
            </ul>
            <p>
                The first question sets your everyday expectations for yourself. And, be reasonable.
                Maybe its two hours a day or three days a week. Make it achievable, but, most importantly, make it
                consistent.
            </p>
            <p>
                The second question sets your deadline for almost-ready software. It's a stake in
                the ground a short time from now where your co-worker, friend, or spouse gets a
                crack at what you've done. It helps you work backwards to figure out how much you need to do 
                between now and then.  Couple this with how much time you spend per day and week, and you'll
                know how much needs to get done every session.
            </p>
            <p>
                The third question gets you ready for "good enough" software. Software that's got
                all the big things right and is good enough for the general public. It's launch-ready.
                Don't set this date too far from the date you show your friends. And, it's web-based
                software. It doesn't have to be perfect.
            </p>
            <p>
                That's where the fourth question comes in. It sets you up for everything thereafter.
                You've launched and now you've set up a time to push new releases. Perhaps, it's
                a week after launch. Because we're talking about web-based software, it can be just a few
                days (or even hours) after launch. Once you've actually gotten
                to this stage, you're off and running.
            </p>
            <p>
                These time constraints create the walls you need to fill in with work. It helps
                you define your most important features. It gives purpose to each moment you put
                into your software. Without rigid time constraints, you can go on forever wondering
                if you've put enough time into something or make excuses that other things take
                priority. 
            </p><p>Instead of getting ready to deliver something, you'll be feature creeping, 
                re-evaluating, and procrastinating every step
                for as long as you please. Productivity dries up when you don't have that sense
                of urgency. Time constraints keep you progressing.
            </p>
            <p>
                But, what if you truly have a pet project? What if it's just something you're doing
                for fun on the side and learning new skills along the way, and nothing more? Set
                the time parameters anyways. Even if they are arbitrary stakes in the ground, <strong>set them</strong>. 
                If you care about staying productive, turn your pet projects
                into real projects, with a real deadline. Force yourself to learn what you need
                to learn in that given amount of time.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-16">
                #16: Set a deadline, even if it's arbitrary</h3>
            <p>
                I started building my company's first product, <a href="http://www.getdonedone.com">DoneDone</a>,
                 in October, 2008. DoneDone is
                a simple, web-based bug tracking tool that focuses on clarity and workflow over
                features. It started because we didn't like the other bug tracker we were currently
                paying $120/month for. I could do something better.
            </p>
            <p>
                When client work sputtered for a few weeks, I began coding. If we were willing to
                pay for our current bug tracker, others would certainly pay for something better.
                And so, motivation started with those two thoughts:
            </p>
            <ul>
                <li>Make something better.</li>
                <li>Make some money.</li>
            </ul>
            <p>
                For the first few weeks, I worked with only ideas. No wireframes, specifications,
                or even Photoshop files. I just wrote code, built UI, tested, refined, and wrote
                some more. I was still in the honeymoon period of development. Though I was directionless,
                the thought of making money off a product was enough motivation to start.
            </p>
            <p>
                Fast-forward a few months later. It was November, 2008. Client work trickled in,
                and naturally, my pet project shuffled to the back of the priority line. Every
                few days, I could carve out a couple of hours to build DoneDone, but the hours were
                sluggish and unproductive. It was hard to decide what to do with the infrequent buckets of time I
                could carve out for myself. 
            </p>
            <p>
                Instead, we needed a new approach. We had to treat DoneDone with the urgency of a client project. 
                What was the difference between this project and projects we'd done for other clients? We were our
                <em>own</em> client.  And just like a client project, we needed a set of dates. A date to release DoneDone internally.
                A date to launch the product to the public. And dates to release iterations thereafter.
            </p>
            <p>
                In the end, we came up with the completely arbitrary date of April 15, 2009, roughly
                6 months from the start. A pet project suddenly became a real project.
            </p>
            <p>
                From that stake in the ground, we could now work backward. We needed to add in the
                payment gateways, figure out our cost structure, build a marketing site, and clean
                up our feature set. With a deadline set, we could now fill that time in with a requisite
                amount of work. The sense of urgency came back. I could be productive again.
            </p>
            <p>
                In early April, I set up a DoneDone week on our company blog. Each day focused on
                a different aspect of the application. I chose 5 things to focus on, one for each
                day of the business week. Even the marketing write-ups were based on an arbitrary
                set of time.
            </p>
            <p>
                We launched on April 15th, simply and solely because that's the date we set. There
                were certainly other features to add. Looking back on it, it's hard to imagine DoneDone
                ever not having them. We did not have an email-to-ticket or tagging system for issues,
                both core pieces of the product today. But, they simply did not make it to launch.
                We focused on the most important features a bug tracking tool of 6 months requires.
                On April 15th, the project was launched to the public, productivity still running
                high.
            </p>
            <p>
                Have I really written nearly a whole chapter's worth about setting deadlines?
                Yes. In all it's un-revolutionari-ness, it's amazing how many people still simply
                do not set deadlines for their own work.
            </p>
            <p>
                It's not just about setting an end date. Deadlines create a sense of urgency that
                gets you to the finish line. It's making you your own best boss, especially when
                you've got no one else breathing down your neck.
            </p>
            <p>
                Finally, deadlines keep your work relevant. When you let your project bleed
                from months into, even, years, your product might not have the intended worth it
                had when you began. 
            </p>
            <p>
                Jack Dorsey spent less than three months from initial concept
                to launching the first version of a, then, little-known SMS messaging service that
                later would be called Twitter.
                Imagine if, instead, he had spent years and years on development instead of the
                short burst from start to launch. Things might have turned out differently.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-17">
                #17: Constrain your parameters</h3>
            <p>
                It's not just about time. If your software costs money to build (hosting, hired
                help, coffee), put a cap on it. What can you do with a few hundred bucks a month?
                Capping cost makes you creative. It means you might have to figure out a more efficient
                way of using your resources. It forces you to think smart. And smart thinking keeps
                you productive.
            </p>
            <p>
                Consider all the sad stories of lottery winners. People working 9-to-5 jobs just
                to make ends meet and struck it rich. They buy cars, jewelry, yachts, and homes.
                They give away thousands to re-emerging long-lost relatives. Then they go into debt
                and are worse off than not having won at all. They didn't realize that, even 50
                million dollars is a finite amount of money. The walls, while spread further apart,
                were still there. They just didn't think to find them.
            </p>
            <p>
                When you don't have walls around you, whether they are walls around time, cost,
                or a feature set, you lose sight of reality. You make questionable decisions because
                nothing is forcing you to make them firm. If you want to develop great software,
                set up and obey the walls around you. Then build.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-18">
                #18: Cut the detail out of the timeline</h3>
            <p>
                In twelve years of web development, I've never seen a project go exactly as planned.
            </p>
            <p>
                Functionality changes. Unanticipated obstacles arise. And, sometimes things that
                you thought might take longer, simply don't.  And yet, all too often, we put too much <em>detail</em>
                into a project timeline. Putting a delivery time toward every single page, view,
                function, UI component, or interaction means you've become a slave to your timeline.
                You've decided how long every single step will take without having taken any of the steps 
                yet. If you're going to plan, you might as well plan with less detail.
            </p>
            <p>
                Build timeline deliverables in sizeable chunks, not in small breadcrumbs.
                If you're estimating an eight week project, give yourself eight weekly deliverables rather than
                40 daily ones. Instead of defining when each individual interaction of your application
                can be delivered, decide when complete section can be delivered.  In the end, it's the same
                amount of time, but with less checkpoints in between.
            </p>
            <p>
                When your timeline is too detailed and your delivery dates too frequent, there's no wiggle 
                room to experiment or reconsider the details of an application as you go. You're forced to stick 
                to a rigid schedule of guessed tasks. And, when one or two of those small tasks goes wrong, suddenly,
                the entire timeline feels like it's crumbling right in front of you.
                That's not motivating, nor is it how good software gets built.
            </p>
            <p>
                Giving yourself a reasonable amount of time between deliverables enables you to play.
                It breaks down a large project into bite-size mini-projects where you <em>still</em> get
                the chance to begin where you love to begin. It gives you the chance to iterate
                a few times before your next deadline.  A week (or two) before your next deliverable gives you
                the opportunity to make a few mistakes and still recover.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-19">
                #19: Make your product better in two ways everyday</h3>
            <p>
                Development can get dull.  At times, I'd like 
                to do something else &mdash; paint a picture, wash my car, perform open-heart surgery on an endangered
                animal &mdash; <em>anything</em> but this.
            </p>
            <p>
                In the proverbial dog days of development, sustainable productivity has to come from
                small victories. Money, fame, delusions of grandeur, and the simple satisfaction
                of coding won't keep you productive all the time. There has to be an everyday nugget
                of inspiration &mdash; a baseline motivator that exists even when the big motivators grow
                stale.
            </p>
            <p>
                I've spent a few years building a web-based data modeling application called <a href="http://www.x2oframework.com">X2O</a>.
                X2O creates the software framework we use for every web project at <a href="http://www.wearemammoth.com">We Are Mammoth</a>.
                It generates an interface to build an application's data model, and generates the
                database, data access layer, and web services, so you can quickly build customized database-driven apps.
                You'll learn about it in a lot more detail in the next chapter on automation.
            </p>
            <p>
                X2O is an application with lofty goals. It is wildly complex in places, with a whole
                lot going on underneath the hood. When broken down, it's a synthesis of a several dozen 
                applications that help generate different parts of your custom app. Maintaining
                passion to keep building it is hard because each of these apps is a big application
                in itself. Building big stuff like this requires
                small victories.
            </p>
            <p>
                While I was knee-deep in development, I put a new rule into my day-to-day efforts on X2O: 
                Make two things better about it each day.
            </p>
            <p>
                I have an end-goal. One day, I'd like to wrap this entire framework up into a bow
                tie, figure out a way to distribute it to the outside world, travel the world and
                market it. But, spending too much time daydreaming about the end game doesn't help
                X2O get better. Real work has to be done.
            </p>
            <p>
                When productivity is running low, I keep to a simple rule: Make two improvements
                to your product every day. They don't have to be big improvements, like wrapping a security
                layer around the application. They can also be little ones, like creating more elegant,
                friendly error messages on the UI. Some days I'll have the energy to tackle a big
                task and a little one. Other days, maybe two minor ones. In the end, everyday I
                know that X2O <em>today</em> is quantifiably better than X2O <em>yesterday</em>.
            </p>
            <p>
                There's significance in the number 2 as well. One improvement can sometimes be daunting.
                Which one do you choose? One is also too close to zero. One makes it easy to convince
                yourself that you could skip today and make up that extra one tomorrow. On the other
                hand, three seems like too much to sustain every day. Two is a magical number. I
                can find time, even on a busy day, to squeeze out two new little nuggets of goodness
                into my product. It's hard work, but sustainable.
            </p>
            <p>
                And remember, it's two ways to make your product better, not necessarily two new
                features. "Better" can also come from getting rid of stale code, refactoring, commenting,
                and re-organization.
            </p>
            <p>
                Deciding to make your product better in two ways everyday is a good mental exercise
                to keep those large projects moving forward. In a working week, you'll have 10 better
                things to say about your product than you do now. In a working month, you'll have
                40 better things to say about your product than you do now. That's real, everyday
                progress.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-20">
                #20: Invest in good hardware</h3>
            <p>
                Distractions are the enemy of productivity. The more little things that get in your
                way each time you try to get work done, the less productive you'll be. It's especially
                true for us programmers, where any little distraction can disrupt a sometimes complex
                train of thought.
            </p>
            <p>
                So, productivity starts with every <em>little</em> thing that surrounds your work
                environment. There are so many things that can distract you when you should be working
                at your best. Your work environment should do everything to minimize that distraction.
            </p>
            <p>
                For starters, invest in the right hardware. The financial costs you put in up-front
                will invariably pay off every day, in <em>the currency of productivity</em>.
            </p>
            <p>
                At We Are Mammoth, we recently made the upgrade from using fiver year old Dell towers
                running Windows XP to a MacBook Pro running Windows 7 on Parallels. The investment
                was monetarily substantial, but, for that singular, one-time down payment, we reap
                the benefits every single minute we're working.
            </p>
            <h4>Why I love my MacBook Pro</h4>
            <p>
                <em>Full disclosure:</em> And now, I will preface the remainder of this chapter 
                by saying that I am a converted Macophile. You may <a href="#lesson-21" class="chapter-link">skip to the next
                chapter if you'd like</a>.
            </p>
            <p>
                Running Windows on the Mac lets me take advantages of both platforms.  I
                can run Photoshop on the Mac, in a pinch, while still working on .NET apps with Visual
                Studio on the Windows side.  Plus, I can test IE, Firefox and Safari on both PC and Mac
                without having to setup a cast-off computer (the ones companies typically denote, the "Browser
                Test Machine").
            </p>
            <p>
                With our new laptops, our developers are more mobile now. Our applications take fractions 
                of the time to load on newer, faster processors. 
            </p>
            <p> 
                I've even fallen in love with the keyboard. The keys 
                are flat and thin. They
                have just the right responsiveness to the touch. They let me type more fluidly and
                seamlessly with the code I see in my head. I make less mistakes.
                Compare that to the bulkier, stickier nature of traditional keyboards. Even if every
                keystroke is just 10% more efficient, and I can reduce my errors by a few less a
                day, that multiples over time.
            </p>
            <div class="cartoon">
                <img src="http://www.andertoons.com/img/cartoons/2502.jpg"/>
            </div>
            <p>
                And when you buy a better machine, make sure you get a video card that can support
                multiple monitors. Along with our glistening new laptops, we supply every developer
                with a secondary monitor. The more screen real estate you have, the more open applications
                you can have in front of you without needing to flip between states. If you have
                the luxury of a two-monitor setup, keep your main monitor (or laptop) directly in
                front of you, off to either the left or right of you, or <a href="http://www.humanscale.com/products/product_detail.cfm?group=L2">splurge 
                on a laptop stand</a>.
            </p>
            <p>
                In a dual monitor setup, keep your programming environment in the full-screen directly
                in front of you. In the other screen, keep up your test browser and have any other
                programs (like email or chat clients) accessible from there as well. This way, you
                can stay focused on your development and testing on one screen at all times.
            </p>
            <p>
                If you have a triple monitor setup, keep your programming environment directly in
                front of you, your test browser up on one screen and all the other programs (email,
                chat) on a 3<sup>rd</sup>.
            </p>
            <p>
                Scan a typical web development office and you can quickly tell whether management's
                in-touch with their development team.  Count the number of monitors in the room and divide
                by the number of employees.  This number is your <em>In-touch</em> quotient.
            </p>
                <table class="chart" cellspacing="0">
                    <thead>
                        <tr>
                            <th><em>In-Touch</em> Quotient</th>
                            <th>Diagnosis</th>
                        </tr>
                    </thead>
                    <tr>
                        <td>1</td>
                        <td>Not very in-touch</td>
                    </tr>
                    <tr>
                        <td>1 - 2</td>
                        <td>Somewhat in-touch</td>
                    </tr>
                    <tr>
                        <td>2.1 - 3</td>
                        <td>Maximally in-touch</td>
                    </tr>
                    <tr>
                        <td>> 3</td>
                        <td>You're actually in a day-trader's office.  Leave <strong>immediately</strong>.</td>
                    </tr>
                </table>
            <p>
                The machine you've been 
                running on for a few years may seem fine to you, and you might be accustomed to its temperaments. But
                spending those extra few thousands of dollars is an <em>investment in productivity</em>, not just
                an expenditure.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-21">
                #21: Establish "off-time" and let your co-workers do so too</h3>
            <p>
                Productivity can only happen when there's time allowed to be productive.  It's less 
                obvious than it sounds.  Basic events in everyday work &mdash; meetings, phone calls, shoulder-tapping &mdash;
                are so commonplace now that we forget these are all <em>distractions</em>. 
            </p>
            <p>
                How have some companies solved the distraction issue? <a href="http://www.37signals.com">37signals</a> preaches 
                staying away from your employees. Interruption not only stops
                you from working on the thing you're working on, but breaks you out of your natural
                zone &mdash; that state of being completely concentrated on your work. Google is well-known for their "20% rule" 
                (allowing engineers a day a week to work on their own projects). 
            </p>
            <p>
               Companies that want their employees to thrive, not just
                survive, need ways of allowing that to <em>actually</em> happen.
            </p>
            <p>
                In our business, we are far more productive when we take the occasional day to work
                from home. Extracting yourself from the nagging feeling that there's a client call
                looming, or someone needing your help on something <em>right now</em> is a huge
                burden off.
            </p>
            <p>
                But, we also serve clients that sometimes need lots of attention.  
                And, sometimes <em>we</em> need lots of attention from each other as well. If you work
                for clients, you may not have the luxury of full days of pure programming. There
                will always be fires to fight, clients to call, and emails to answer.
            </p>
            <h4>
                Welcome, OFF-time</h4>
            <p>
                A few years ago, I instated OFF-time at We Are Mammoth. It's a way of mimicking
                the "get-out-of-my-face-and-just-let-me-work" rules that other companies implement,
                without much compromising to our client's needs (a.k.a. calls, emails, and general
                attentiveness). Here's how it works:
            </p>
            <p>
                We have 2 hour shifts of OFF-time for each developer, every day. Here are the 5
                commandments of OFF-time:
            </p>
            <ul>
                <li>No emails need to be answered.</li>
                <li>No meetings. You are unavailable during this time.</li>
                <li>No phone calls.</li>
                <li>No co-worker IMs you.</li>
                <li>No co-worker talks to you.</li>
            </ul>
            <p>
                During OFF-time, you place a white flag on your desk. If you're at home, then you
                just put your away status on AIM. After 2 hour's off, you check your email, your
                phone calls and generally come back to the world. Then, proceed as normal. The golden
                rule is simple: Just don't bug the next person on OFF time.
            </p>
            <p>
                It would be great to have company-wide off time, but it's unreasonable for most
                companies. It means a company essentially shuts down from any client or internal
                communication for two hours. It's a hard feat given we are still primarily a client-oriented
                business. Instead, we set up three staggered shifts. They look something like this:
            </p>
            <ul>
                <li>Shift 1: 10am-noon daily – Ka Wai, Michael</li>
                <li>Shift 2: 2pm-4pm daily – Anthony, Mustafa</li>
                <li>Shift 3: 4pm-6pm daily – Tom, Craig</li>
            </ul>
            <p>
                Because shifts are staggered, only one or two people are off at any time. So, the
                company doesn't just shut down. We are, for the most part, available.
            </p>
            <h4>
                Someone else can help you</h4>
            <p>
                Another key is pairing up different roles for each OFF-time shift. I tend to work
                closest with Mustafa, Tom with Mike, and Anthony with Craig. So, we don't share
                the same OFF-time.
            </p>
            <p>
                That means, if there's an urgent issue, a natural counterpart is available to discuss
                it. If Craig has a question for me at 11:30am, he goes to Mustafa. If I have one
                for Tom at 4:30pm, I can ask Mike. Find a counterpart that can handle all the questions
                that you could handle, and differentiate your off-time hours.
            </p>
            <h4>
                Interruption as the last resort</h4>
            <p>
                Since OFF-time cuts you off from the person on it, it also makes you think harder
                about your own problems. Is this something you can solve with a little research?
                Interruption is becoming the last resort.
            </p>
            <p>
                OFF-time gives each of us 10 hours of interruption-free time a week, with almost
                little disruption to our availability to clients and ourselves. It's a great way
                to sustain productivity.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-22">
                #22: Keep a personal to-do list</h3>
            <p>
                It's amazing how something as simple as a checklist of items can alter your productivity.  Enter 
                the personal to-do list.
            </p>
            <p>
                A personal to-do list is <strong>not</strong> a project timeline or a Gantt chart.
                Those documents serve a group. They are too sweeping for a single person. They make
                projections about the broad scope of a project rather than lay the path for the
                next couple of paces ahead of you. While they are useful "big picture" documents,
                they don't help you organize.
            </p>
            <p>
                A personal to-do list is <strong>not</strong> an overflowing email inbox. Using
                your emails to remind you of things you have to do is futile. Email is a smorgasbord
                of fragmented conversation and questions interspersed with un-prioritized tasks
                &mdash; not a clearly defined list of things to do right now. Email isn't made for quick
                scanning.
            </p>
            <p>
                A personal to-do list is <strong>just a checklist, alright????</strong> Nothing more, nothing less.
                It's quick and simple, but deceptively
                powerful.
            </p>
            <p>
                When you receive a task in your inbox, write the task down in your personal to-do
                list. When you've adjusted your timeline to accommodate a must-have feature, breakdown
                that feature into small to-dos on your personal to-do list.
            </p>
            <p>
                At first glance, the personal to-do list seems like just another thing to manage &mdash; all
                the items in it likely originated from some other document. That smells like bad practice because it 
                violates the "don't repeat yourself"
                mantra most of us follow in our code. But, a personal to-do list is a rare occasion where duplication is <em>essential</em>.
                That's because it doesn't serve the same purpose as other, more rigid, documents.
            </p>
            <p>
                Unlike other documents, the kind of to-do list I'm advocating is made for constant daily adjustment. It is
                never set-in-stone. To-dos are added, checked off, pushed back, pushed up, and thrown
                out daily. Unlike project timelines and Gantt charts, a personal to-do list doesn't
                care about the past. Its starting point is always right now. It also doesn't project
                anything. It's full of organized, real tasks that have to get finished in the very
                near term.
            </p>
            <p>
                A good personal to-do list has the following qualities:
            </p>
            <ul>
                <li>It is one, and only one, list.</li>
                <li>It has four divided areas: <em>Today</em>, <em>Tomorrow</em>, <em>Two days from
                    now</em>, and the <em>Future</em>.</li>
                <li>It is one-level deep, not a multi-level tree. This makes it easy to scan.</li>
                <li>It's easily modifiable. You can move items up and down the list easily.</li>
                <li>Each to-do in any of the first three buckets should take an hour or less. Items
                    in the <em>Future</em> bucket can be broader.</li>
                <li>It's online. You have access to it wherever you're working.</li>
            </ul>
            <p>
                I use <a href="http://www.tadalist.com">Tadalist</a> from 37signals because it's simple and free. To-do
                lists shouldn't be robust software. Tadalist lets you do only a few things: Create
                lists, add items, edit items, delete items, and re-order items. Here's how you set
                up a personal to-do list using Tadalist:
            </p>
            <ul>
                <li><strong>Step 1:</strong> Create a list called "Personal To-Do List"</li>
                <li><strong>Step 2:</strong> Add 4 divider items (In Tadalist just make them 4 to-do items
                    that you'll never actually check off):</li>
            </ul>
            <pre>
--- TODAY ---
--- TOMORROW ---
--- TWO DAYS FROM NOW ---
--- FUTURE --- 
                        </pre>
            <p>
                As you start adding to-dos, put them under their appropriate divider. If it's something
                you need to do today, drag it under <span class="code">TODAY</span>. If it's something that needs to be done
                tomorrow, drag it under <span class="code">TOMORROW</span>. If it's just further out, put it under <span class="code">TWO DAYS
                FROM NOW</span>. If you're not sure when, or need to keep a broader task in mind, drag
                it under the <span class="code">FUTURE</span>.
            </p>
            <p>
                Remember, nothing about a to-do list is final. If you're unsure whether to put something
                under <span class="code">TOMORROW</span> vs. <span class="code">TWO DAYS FROM NOW</span>, lean toward the closer date. 
                If you get to tomorrow and it still hasn't become top priority, you can leave it for tomorrow
                again.
            </p>
            <h4>
                Breaking down features into to-dos</h4>
            <p>
                Any to-dos you bring under <span class="code">TODAY</span>, <span class="code">TOMORROW</span>, or 
                <span class="code">TWO DAYS FROM NOW</span>, should be small
                tasks (no more than a couple of hours). For instance, <span class="code">"Build registration and login"</span> is a bad
                to-do. Too much time goes by before you're able to see progress on your to-do list.
                Instead, <span class="code">"Build registration and login"</span> might be added as a series of these bite-size
                tasks:
            </p>
            <pre>
--- TODAY ---
Registration: Build HTML form
Registration: Implement JS validation
Registration: Verify email uniqueness
Registration: Send email confirmation
--- TOMORROW ---
Login: Build login form
Login: Implement JS validation
--- TWO DAYS FROM NOW ---
Login: Build "Forgot password" form
Login: Send "Forgot password" email
Login: Build "Reset password" form
Login: Build "Reset password" confirmation
--- FUTURE ---
Something down the road...
                    </pre>
            <p>
                We've broken down building a registration component into a 3-day, 10 to-do task.
                It's organized without seeming overly complex.
            </p>
            <p>
                Each to-do is a small chunk of work. Once you finish one, you can check it off.
                It gives you instant gratification each time you <em>finish</em> something. Instead
                of waiting until you complete an entire component, you see progress frequently as
                you go.
            </p>
            <h4>
                How tomorrow becomes today</h4>
            <p>
                To-do lists start with today. So, what happens when you wake up tomorrow? Spend
                5 seconds to get your to-do list updated again. In Tadalist, it's two moves with
                your mouse:
            </p>
            <ul>
                <li>Drag the <span class="code">TOMORROW</span> divider just above the <span class="code">TWO DAYS FROM NOW</span> divider. Everything that
                    was set for tomorrow now falls under <span class="code">TODAY</span>. Anything you didn't get to yesterday
                    remains in <span class="code">TODAY</span>.</li>
                <li>Drag <span class="code">TWO DAYS FROM NOW</span> just above the <span class="code">FUTURE</span> divider. Everything that was set for
                    2 days out now falls under <span class="code">TOMORROW</span>.</li>
            </ul>
            <pre>
--- TODAY ---
Login: Build login form
Login: Implement JS validation
--- TOMORROW ---
Login: Build "Forgot password" form
Login: Send "Forgot password" email
Login: Build "Reset password" form
Login: Build "Reset password" confirmation
--- TWO DAYS FROM NOW ---
--- FUTURE ---
Something down the road...
                    </pre>
            <h4>
                Back to the future</h4>
            <p>
                Each day, glance at your growing list of FUTURE items. If you'll need to finish
                one of those items in the next 2 days, break that task down into bite-size tasks,
                and move them appropriately. In a few seconds, you have a quick gauge of what your
                workload looks like.
            </p>
            <h4>
                Re-evaluating what matters each day</h4>
            <p>
                A personal to-do list is perfectly made for adjustments to priority. It rolls with
                the everyday uncertainty of software development. Perhaps an item that's destined
                to be done today doesn't seem as important anymore. Just drag it into the TOMORROW
                bucket or even further down. Similarly, an item set for TWO DAYS FROM NOW may be
                something you have the energy for today. Move it, finish it, and check it off.
            </p>
            <p>
                There will be many days when you won't get to all of your TODAY items. You may have
                an item stuck on TODAY for day's on-end because other priorities got in the way.
            </p>
            <p>
                But after awhile, you'll notice something extraordinary. Certain to-dos always seem
                to linger around your TODAY bucket or routinely get pushed back to TOMORROW. These
                "bad egg" to-dos might not be as important as you thought when you first added it.
                <em>Get rid of to-dos that grow stale on your list</em>. Avoiding unimportant work
                is just as productive as completing important work.
            </p>
            <div class="cartoon">
                <img src="http://www.andertoons.com/img/cartoons/1613.jpg"/>
            </div>
            <p>
                A personal to-do list is not black magic – it will not do your work for you. But,
                it helps you organize and adjust simultaneously. It leads you to productivity.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-23">
                #23: Write code as a last resort</h3>
            <p>
                I love the story of the unhappy tenants in a New York city office building.
                When residents complained about the increasingly poor service of the elevators,
                a consulting firm concluded that long wait times were the issue. Solving the tenant's
                complaints meant potentially adding new elevators and implementing new computer
                controls to improve elevator efficiency – all very costly adjustments.
            </p>
            <p>
                Enter the young psychologist hired in the building's personnel department. He recommended,
                instead, placing mirrors in the elevator lobby. The problem of waiting times, in
                his mind, was really a problem of boredom. His suggestion worked.  People stopped complaining
                about waiting for the elevator when they had something to do &mdash; observe themselves. Same problem solved
                with a very different solution.</p>
            <p>
                The most passionate of us are the ones who spend most of our work time thinking
                critically and creatively, often to find simpler, "lazier" solutions. The answer
                isn't always to plow ahead with the obvious, brute-force solution. In our world, the brute force solutions
                would be simply writing more code.</p>
            <p>
                Sometimes, the best answers are found somewhere else. Think to yourself, the next
                time you're confronted with a New York office building elevator problem...</p>
            <ul>
                <li>Has someone already done this task before? Can I use something off-the-shelf to take
                    care of the dirty work for me?</li>
                <li>Is this piece of functionality really important to the goals of the application?
                    Is the task already there, but just through a different user experience?</li>
                <li>Is this an automatable task? Can I write software to write this algorithm for me,
                    so I don't have to repeat this work again?</li>
                <li>Is there a simpler way to code what I'm coding right now that might be worth the tradeoff, even if it doesn't solve the problem entirely?</li>
            </ul>
            <p>
                As a last resort, the passionate coder actually...writes code. In today's landscape,
                there are so many opportunities to not write it.
            </p>
            <p>
                When you go straight into "writing code" mode at every task, you lose the opportunity to think
                about why you're really writing it. When you, instead, think "does this
                need to be implemented in <em>this</em> way", you focus your coding efforts on the
                elements that, truly, are important for solving your problems.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h2 id="automation">
                Automation</h2>
            <p>
                Cooks, cleaners, baristas, accountants, cashiers, construction workers, bankers,
                mortgage lenders, and doctors. What do these jobs have in common? They require you
                to repeat the same skill set each day. Sure, the most talented chefs are inventing
                new dishes. The best doctors are researching innovative new ways to make people
                better. But, most find a specialty, perfect it, and repeat the craft over and over
                for years and years. Their work becomes by-and-large, algorithmic.
            </p>
            <p>
                Software developers do this too. You can be great at building shopping carts, content
                management systems, web services, or login components. You can spend years working
                on the same types of things over again and again. Granted, it might be harder to
                find that kind of work over time. Technology shifts at a blazing rate. The languages,
                platforms, and hardware you're using now will likely become a liability a few years
                from now. But, do realize, programmers are still forced to
                use and program against IE6 these days. And, even <a href="http://www.ie6countdown.com/">Microsoft 
                doesn't want you programming for IE6 anymore</a>.
            </p>
            <p>
                There will always be work for the dinosaurs.
            </p>
            <p>
                By contrast, look at sculptors, musicians, architects, actors, writers, and directors.
                They find inspiration in expanding and forging new ways of doing their work. Many
                actors choose roles specifically to avoid being typecasted. It's every actor's biggest
                fear &mdash; the realization that they are <em>always</em> the villain, the victim, the
                comic, or the outcast every time. Think Bill Murray's break from
                comedy in <em>Lost In Translation</em>.
            </p>
            <p>
                Musicians fear this same predictability as well. Some of the most well-known musicians
                reinvented themselves in their prime. Just listen to the Beatles' <em>Revolver</em>,
                Bowie's <em>The Man Who Sold the World</em>, or U2's <em>Achtung Baby</em>. They
                found hunger for something more than just repeating themselves, departing from a
                style they had already mastered.
            </p>
            <p>
                The beauty in software development is that you can choose to fall under <em>both</em>
                buckets of work. You can keep working on concepts you've already mastered, that
                have become algorithmic, or push for something new. You can solve more complex,
                more interesting, and more rewarding problems.
            </p>
            <p>
                I'd like to think the latter is a more interesting place to spend your day. And,
                fortunately, you <em>can</em> spend it there.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-24">
                #24: Separate human work from robot work</h3>
            <p>
                There is simply no reason a software developer today should resort to doing the
                same mechanistic things over and over again. We have the unique
                luxury of working in a medium that can help do <em>the work for us</em>. 
                A musician can't write music that writes music and a director can't direct a movie
                that directs other movies &mdash; but a software developer <em>can</em> write programs that
                write other programs.  It's our own dirty little secret.
            </p>
            <p>
                Yet, as an industry whole, we aren't taking advantage of this as much as we ought to.
                We've all had moments of déjà-vu programming. You've pasted code from an old project
                and tweaked it slightly to fit the new one, or you've just spent hours writing functionality
                you know you've written many times before. This has got to stop. There are better,
                faster, and more rewarding ways to go about your work.
            </p>
            <p>
                If you're finding yourself doing this often, be more cognizant of it. Separate the code you find 
                yourself repeating from the code that's unique.
                Identify and extract work that feels like a repeat <em>process </em>(not just copy-and-paste
                code) and don't repeat them. Let software <em>write</em> the tedious and repeatable
                work for you. This is code generation.
            </p>
            <div class="cartoon">
                <img src="http://www.andertoons.com/img/cartoons/6152.jpg"/>
            </div>
            <p>
                You may have heard about code generation before, but if you're not doing at least
                a small amount of it, you may not have fully considered all of its incredible benefits.
            </p>
            <h4>The story of little Carl Friedrich Gauss</h4>
            <p>
                The famous mathematician, Carl Friedrich Gauss grew up in Germany in the late 18<sup>th</sup>
                century. As the story goes, his grade school teacher was notoriously lazy and wanted
                to keep his pupils occupied for long periods of time. In hopes of keeping his mind
                busy for a long while, the teacher had Gauss sum all the numbers up from 1 to 100.
                After only a few minutes, much to the teacher's chagrin, the young Gauss came back
                to his teacher with the answer: <span class="code">5050</span>.
            </p>
            <p>
                How did he come up with the answer so quickly? If Gauss had the tools to write code
                back then, he might have written some code like this to get to the answer:
            </p>
            <pre>
public int sum_range_of_positive_integers_to_100()
{
    int sum;
    for (int i = 1; i &lt;= 100; i++)
    {
        sum += i;
    }
    return sum;
}
</pre>
            <p>
                After some quick thinking, he might have re-written his program to something a little
                more generic, in case the teacher was to challenge him again with a different range of numbers.
            </p>
            <pre>
public int sum_range_of_positive_integers(int first, int last)
{
    int sum;
    for (int i = first; i &lt;= last; i++)
    {
        sum += i;
    }

    return sum;
}
</pre>
            <p>
                Of course, young Gauss didn't have such a luxury at the time. So how did he get to the answer so
                quickly? 
            </p>
            <p>Rather than adding up the numbers one-at-a-time, he approached the
                problem in a far more clever way. Instead of brute-force addition, he summed the numbers
                up pairwise, starting with <span class="code">1</span> and <span class="code">100</span>, followed by 
                <span class="code">2</span> and <span class="code">99</span>, <span class="code">3</span> and <span class="code">98</span>, and so forth.
            </p>
            <code>(1 + 100) + (2 + 99) + (3 + 98) + ... + (49 + 52) + (50 + 51). </code><code>101
                + 101 + 101 + ... + 101 + 101 + 101 </code>
            <p>
                From here, a simple pattern emerges. It turns out there are 50 pairs of numbers
                that each sum up to the magic number, <span class="code">101</span>. The problem of summing up all 
                100 numbers together was reduced to a simple multiplication equation:
            </p>
            <code>50 X 101 = 5050. </code>
            <p>
                Gauss's approach was a uniquely <em>human</em> one. He took a problem that appeared
                tedious at the surface and came up with an elegant way to solve it. He found a better
                heuristic instead of resorting to the über-tedious brute-force approach. As
                it turns out, he fell upon a nifty little formula.
            </p>
            <code>Sum of all numbers from 1 to n = n(n+1) / 2 </code>
            <p>
                This formula is far more palatable for a human to calculate than brute-force addition
                would be. It's busy work <em>fit</em> for a human to do.
            </p>
            <p>
                How would our code approach this problem? The code written earlier in this chapter would
                have produced the same answer, only doing it the "brute-force" way &mdash; the exact way
                we told it to. And, given how fast processors work these days, it would have arrived at the answer 
                much faster than even Gauss did, despite the inefficiencies in its approach.
            </p>
            <p>
                But, at a certain point, Gauss's approach would win out. If Gauss were asked
                to sum all the numbers from <span class="code">1</span> to <span class="code">4,273,558</span>, <span class="code">sum_range_of_positive_integers()</span> would
                take a lot longer to compute. 
            </p>
            <p>
                This means that, at some number, Gauss would likely have been able to <em>beat the code</em>
                to the answer. Because, while Gauss cunningly knew that the answer lied in evaluating
                one simple equation, the code would get to the answer in the incredibly inefficient
                way it was told to do so:
            </p>
            <code>1 + 2 + 3 + 4 + 5 + 6 + .... + 4,273,556 + 4,273,557 + 4,273,558. </code>
            <p>
                Let's rewrite the function using Gauss's bit of ingenuity:
            </p>
            <pre>
public int sum_range_of_positive_integers(int last)
{
    // A solution Gauss would be proud of...
    return (last * (last + 1)) / 2;
}
</pre>
            <p>
                Now, we've turned the function into a highly efficient one. No matter what the input,
                it will perform at just about the same rate of efficiency. Summing <span class="code">1</span> to 
                <span class="code">4,273,558</span>
                won't take much longer than summing <span class="code">1</span> to <span class="code">100</span>. Our program won't be slow and it will
                never be wrong. Gauss, unfortunately, for all his cleverness, can't compete with the machine anymore.
            </p>
            <p>
                Let code thrive on the tedious stuff while you, the human being, concentrate on solving those same
                problems in more clever ways.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-25">
                #25: Take advantage of a machine's strengths</h3>
            <p>
                Gauss's tale provides some interesting insight that you might have taken for
                granted in today's world. 
            </p>
            <p>
                Had we kept our initial function intact, a program would have willingly summed all
                the numbers from <span class="code">1</span> to 
                <span class="code">4,273,558</span>. It might have taken a long time, but
                it wouldn't stop unless the machine ran completely out of resources.
            </p>
            <p>
                On the other hand, a human being (like Gauss) approached the problem differently.
                Instead of just going at it, Gauss realized there was a better way. With a little
                bit of creative thinking, he found a way to simplify the problem &mdash; a uniquely
                human quality.
            </p>
            <p>
                People have qualities not found in code
                &mdash; like the ability to reason and analyze outside the boundaries of perceived rules.
                On the other hand, code, unlike people, will follow directions (even unreasonable ones) and
                perform them precisely as directed, to the death.
            </p>
            <p>
                Though these are obvious truths, they are often forgotten and under-utilized in
                our everyday work as programmers. Getting the <em>right</em> systems to work on
                the right <em>problems</em> is the key to real productivity.
            </p>
            <p>
                Here are some other qualities about code you might not have thought about recently.
                Compare each of these to your own work habits.
            </p>
            <h4>
                Code doesn't get lazy</h4>
            <p>
                It will never decide to just take a shortcut or find an easier way of doing things.
                The code snippet at the beginning of this chapter would sum up all 4-million-plus
                integers without deciding to just skip over one. Code executes with impeccable precision.
            </p>
            <h4>
                Code doesn't get bored</h4>
            <p>
                Here are some nonsense instructions:
            </p>
            <pre>
while (x != x + 1)
{
    // do nothing
}
</pre>
            <p>
                As irrational as this task sounds, code will continue to crank at this nothingness
                forever, saved only by a run-time engine that would force an abort sensing this
                loop would be going nowhere fast. Code doesn't analyze the importance of a task.  It has no
                interest in its own well-being. It simply executes.  
            </p>
            <h4>
                Code doesn't forget</h4>
            <p>
                At the beginning of this chapter, I told the engine precisely this:
            </p>
            <blockquote>
                <p>
                    "Whenever I tell you to <span class="code">sum_range_of_positive_integers(1, 100)</span>, create an integer
                    called <span class="code">sum</span>. Starting with the number <span class="code">1</span>, add the value to <span class="code">sum</span>, and then increment
                    the value by <span class="code">1</span>. Keep doing this until you've hit <span class="code">100</span>. Then, give me back the value
                    of <span class="code">sum</span>."
                </p>
            </blockquote>
            <p>
                Years later, I can go back to my software, call the method again, and expect the
                same result. Code doesn't forget what it's asked to do. Software systems, built
                upon thousands and thousands of lines of code, are equally adept. Code, no matter
                its volume, remembers what to do days, weeks, and years later.  Could you?
            </p>
            <h4>
                Code is cheap</h4>
            <p>
                You would understand if the co-worker who would willingly sum the numbers from 1
                to 4-million-plus asked for a raise in return. You could work out some commission
                per summation agreement or agree to an hourly rate. Summing 1 to 10 would be a lot
                cheaper than 1 to 1 billion.
            </p>
            <p>
                We've, fortunately, never taught code about money, market economies, or vacation
                homes. It performs without monetary needs. Code asks for nothing in return. Once
                you've taught code something, you can take full advantage of it. There are no code-labor
                laws, at least as of this writing, to get in your way.
            </p>
            <h4>
                Code is fast</h4>
            <p>
                It executes at a rates incomparable to the way we can finish tasks. It's metered
                by the limitations of hardware, which will become less and less limiting over time.
                Humans are absolutely no match for speed.
            </p>
            <p>
                What does this all mean? Imagine a Craigslist ad that went like this:
            </p>
            <blockquote class="craigslist">
                <p class="header">
                    Diligent Software Programmer Looking for Work!!! (Earth)
                </p>
                <p class="desc">
                    Teach me anything. I'll learn quick and let you know if I need more information
                    instantly. I will work whenever you want, however much you want. I will never forget
                    anything you say and will never complain that I'm not being challenged. I am particularly
                    good at tedious work.
                </p>
                <ul>
                    <li>Location: Anywhere</li>
                    <li>It's NOT ok to contact this poster with services or other commercial interest</li>
                    <li>Compensation: $0</li>
                </ul>
            </blockquote>
            <p>
                Code is inarguably the greatest junior developer that ever lived. It is uniquely
                adept at <em>tedious</em> yet, <em>definable</em> tasks. It never complains &mdash; unless
                your instructions don't make sense. It's cheap, fast, diligent, consistent, and
                unemotional. Don't you wish that on programmers sometimes? The power of code is extraordinary.
            </p>
            <p>
                Programs work amazingly at the tedious but automatable. People are terrible at it.
                When you've figured out what <em>is</em> the tediously automatable stuff, you can
                pull apart the work that you should be doing from the work that you should be building
                programs to do.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-26">
                #26: Think automation</h3>
            <p>
                When my company, We Are Mammoth, first went into business, we
                built Flash-based web sites for a variety of clients. Yes, Flash
                sites. Forgive me, but, this was pre-HTML5, pre-Scriptaculous/jQuery effects, pre CSS3,
                pre Steve Jobs' declaration of war against Adobe.
            </p>
            <p>
                Moving on.
            </p>
            <p>
                A few months into our business, I began smelling repeatable work – work that we
                were doing in the same mechanistic way each time. Having seen the process for a
                few iterations, I could separate the common tedious, yet automatable elements from
                the custom work that applied to each project we built.  They bubbled up like oil in water.  
            </p>
            <p>
                Every application we built followed a common set of themes. We used the same sets of languages
                (C# and AS3) in roughly the same way each time. We used SQL Server to store and retrieve data. 
                Each application needed a data access layer, a series of common web-service commands, and a way to
                parse and fill data from those web services into AS3 value objects on the Flash end.  It turned
                out that variability only lived in two places in our repeatable architecture.
            </p>
            <p>
                First, we couldn't trivialize the data model. We worked on applications for car
                companies, bed manufacturers, brokerage firms, software distributors, fast-food
                chains, and airlines. Their databases were custom-tailored toward solving their
                own unique business problems.
            </p>
            <p>
                Second, we couldn't trivialize the front-end. Design, functionality, and the user
                experience are what make each application different.
            </p>
            <p>
                What we could trivialize was a lot of the work that sat in between the database and user interface. 
                A data access layer (DAL), common web services (transferred via XML), and AS3 value objects (VOs) could all be deduced from the data
                model. In other words, once we defined what the database model and user experience looked like, much of the
                stuff in the middle was automatic. It was obvious what had to be built. It was really tedious,
                banal stuff, fit for robots.
            </p>
            <div class="cartoon">
                <img src="http://www.andertoons.com/img/cartoons/5518.jpg"/>
            </div>
            <p>
                A rough architecture of a typical application looked like this, with the potentially automatable parts 
                in bold:
            </p>
            <p class="center">
                Model &rarr; <strong>DB &rarr; DAL &rarr; XML &rarr; VOs</strong> &rarr; UI<br />
            </p>
            <p>
                Let's see how the automatable parts of an application could be turned into instructions
                for a program to do.
            </p>
            <h4>
                Building a blog from scratch</h4>
            <p>
                Imagine building something as simple as a blog, soup to nuts, by hand. Start with
                the database. The data model might contain three tables that look like this:
            </p>
            <ul>
                <li><span class="code">Posts (ID, Title, CreateDate, Body, AuthorID)</span></li>
                <li><span class="code">Authors (ID, FirstName, LastName)</span></li>
                <li><span class="code">Comments (ID, Comment, EmailAddress, CreateDate, PostID)</span></li>
            </ul>
            <p>
                If you're familiar with database schema modeling, this model is a straightforward one.  
                <span class="code">Posts</span> have a title, body, creation date, and a relationship to one <span class="code">Author</span>,
                via the foreign key <span class="code">AuthorID</span>.  The <span class="code">AuthorID</span> keys into the table <span class="code">Author</span>
                by matching on its <span class="code">ID</span> column.
                <span class="code">Comments</span> have an email address, creation date, and a related originating <span class="code">Post</span>,
                via the foreign key <span class="code">PostID</span>. The <span class="code">PostID</span> keys into the table <span class="code">Post</span>
                by matching on its <span class="code">ID</span> column.
            </p>
            
            <p>
                Next, let's write some SQL procedures to get the data we need out of the database.
                For every table, I can write four procedures for creating, reading, updating,
                and deleting a record from a particular database table. They are widely known as
                <span class="code">CRUD</span> methods. Here's how they might look for <span class="code">Posts</span>:
            </p>
            <p>
                <strong><em>C</em></strong><em>reate post:</em>
            </p>
            <pre>
CREATE PROCEDURE CreatePost (
    @Title NVARCHAR(255), 
    @CreateDate DATETIME, 
    @Body NTEXT, 
    @AuthorID INT) 
AS 
INSERT INTO Post VALUES ( 
    @Title, 
    @CreateDate, 
    @Body, 
    @AuthorID)
</pre>
            <p>
                <strong><em>R</em></strong><em>ead post:</em>
            </p>
            <pre>
CREATE PROCEDURE LoadPost (@ID INT) 
AS
SELECT * FROM Post WHERE ID = @ID
</pre>
            <p>
                <strong><em>U</em></strong><em>pdate post:</em>
            </p>
            <pre>
CREATE PROCEDURE UpdatePost (@ID INT,
    @Title NVARCHAR(255),
    @CreateDate DATETIME,
    @Body NTEXT,
    @AuthorID INT)
AS
UPDATE Post
SET 
    Title = @Title,
    CreateDate = @CreateDate,
    Body = @Body,
    AuthorID = @AuthorID
WHERE
    ID = @ID
</pre>
            <p>
                <strong><em>D</em></strong><em>elete post:</em>
            </p>
            <pre>
CREATE PROCEDURE DeletePost (@ID INT)
AS
DELETE FROM Post WHERE ID = @ID
</pre>
            <p>
                I'd then repeat the same process for <span class="code">Authors</span> and <span class="code">Comments</span>.
            </p>
            <p>
                I then can extrapolate on the relationships between these tables. A post has an
                author. So, I could write a stored procedure to get all the blog posts by a specific author's ID.  Let's call it
                <span class="code">GetAllPostsByAuthorID</span>
                In fact, there's a simple formula to the madness. For any foreign key <span class="code">[Y]</span> in a table
                <span class="code">[X]</span>, I could write a stored procedure of the form: <span class="code">GetAll[X]By[Y]ID</span>:
            </p>
            <pre>
CREATE PROCEDURE GetAll<strong>Posts</strong>By<strong>AuthorID</strong>(@ID INT)
AS
SELECT * FROM [Posts] WHERE AuthorID = @ID

CREATE PROCEDURE GetAll<strong>Comments</strong>By<strong>PostID</strong>(@ID INT)
AS
SELECT * FROM [Comments] WHERE PostID = @ID
</pre>
            <p>
                I might also want to load records by filtering on a specific field. For instance,
                I'll need to get posts for a given day (<span class="code">GetAllPostsWhereCreateDateEquals(CreateDateParam)</span>, or authors by their last name
                (<span class="code">GetAllAuthorsWhereLastNameEquals(LastNameParam)</span>). Another
                formula emerges.  
            </p>
            <p>
                For any filterable field <span class="code">[Z]</span> in a table <span class="code">[X]</span>, given a parameter 
                <span class="code">[P]</span> I could
                write a stored procedure of the form <span class="code">GetAll[X]Where[Z]Equals([P])</span>. For fields that are
                of type <span class="code">DATETIME</span>, let's add a stored procedure that filters posts by a start and end date. Now, we
                have an additional set of <em>deducible</em> stored procedures, by simply introspecting the database schema:
            </p>
            <pre>
CREATE PROCEDURE GetAll<strong>Posts</strong>Where<strong>CreateDate</strong>Equals 
(@CreateDate DATETIME)
AS
SELECT * FROM [Posts] WHERE CreateDate = @CreateDate

CREATE PROCEDURE GetAll<strong>Posts</strong>Where<strong>CreateDate</strong>InRange 
(@StartDate DATETIME, @EndDate DATETIME)
AS
SELECT * FROM [Posts] WHERE CreateDate &gt;= @StartDate AND 
    CreateDate &lt;= @EndDate

CREATE PROCEDURE GetAll<strong>Authors</strong>Where<strong>FirstName</strong>Like 
(@FirstName NVARCHAR(255))
AS
SELECT * FROM [Authors] WHERE FirstName LIKE @FirstName

CREATE PROCEDURE GetAll<strong>Authors</strong>Where<strong>LastName</strong>Like 
(@LastName NVARCHAR(255))
AS
SELECT * FROM [Authors] WHERE LastName LIKE @LastName

// ...and so forth.
</pre>
            <p>
                Stored procedures finished. I can now set my sights on the data access layer and
                middle-layer objects. Again, a pattern emerges. The code that grabs data from a
                database, and the objects that store the data, can be deduced from the structure
                of the database schema.
            </p>
            <p>
                Here's a shortened version of what the classes for <span class="code">Posts</span> might look like in C#:
            </p>
            <pre>
public class Post 
{
    private int _id;
    private string _title;
    private DateTime _create_date;
    private string _body;
    private int _authorID;
    private Author _relatedAuthor;
    //...
}

public class Posts : Collection 
{
    private List&lt;Post&gt; _posts;
    //...
}
</pre>
            <p>
                By examining the Posts table in the database, I can then create parallel methods
                in C# to access the stored procedures I wrote earlier.
            </p>
            <pre>
public void InsertPost(Post post) {}
public Post LoadPost (int ID) {}
public Post UpdatePost (Post post) {}
public void DeletePost(int ID) {}
public Posts GetAllPostsWhereCreateDateEquals(DateTime date) {}
public Posts GetAllPostsWhereCreateDateInRange 
(DateTime startdate, DateTime enddate) {}
public Posts GetAllPostsWhereCreateDateInRange 
(DateTime startdate, DateTime enddate) {}
//... and so forth.
</pre>
            <p>
                Once these data access layer objects are written, I'd move on to create web services,
                write code that would consume and parse these services in AS3, and write corresponding
                value objects in AS3. Again, this code can again be largely figured out from examining
                the structure of the database. For the purposes of this book, I'll spare you the
                details. But, only when all that work is done can I finally pull data from the database
                into the UI.
            </p>
            <h4>Defining the recipe for building an app</h4>
            <p>
                In pseudocode, the recipe for building an application from the bottom-up looks something like this:
            </p>
            <ul>
                <li><strong>Step 1:</strong> Define a database schema</li>
                <li><strong>Step 2:</strong> Build SQL stored procedures</li>
                <li><strong>Step 3:</strong> Build C# data-access layer</li>
                <li><strong>Step 4:</strong> Build web services</li>
                <li><strong>Step 5:</strong> Build objects to consume web services</li>
                <li><strong>Step 6:</strong> Build AS3 value objects</li>
                <li><strong>Step 7:</strong> Hook up data to the user interface</li>
                <li><strong>Step 8:</strong> Design the user interface</li>
            </ul>
            <p>
                After building the database schema, steps 2-7 were surprisingly straightforward for much of the work we did. Much of
                it is deduced by just examining the database. Sure there are custom stored procedures
                and a fair amount of business logic to write that are unique to a blog, but a significant
                amount of the work is automatable. 
            </p>
            <p>
                That automatable work is fit work for the fictitious
                Craigslist job seeker. Or, more realistically, I can <em>write smart programs to do
                    the job for me</em>.
            </p>
            <p>
                In this blog exercise, we've extracted out the common processes of building every
                application from the processes specific to each application. In other words, it
                would be hard to teach a program to "create a blog" but you could tell it how to 
                "create some useful stored procedures given a database schema."
            </p>
            <p>
                Every tiny little repeatable process that I can teach a human being to do, I can
                write a piece of code to do a million times better. Once I've taught the generator
                how to properly write something given a set of inputs, I could always expect the
                same fast, predictable results over and over again. It now frees the human from
                doing repeatable work.
            </p>
            <p>
                It was with this very recipe in mind that I began writing a code generation framework
                called X2O. X2O provides an interface to build a data model, and then generates
                all the underlying tiers of an application based off the data model.
            </p>
            <p>
                After a few months, we saw other opportunities to expand X2O. We could generate
                developer documentation, JavaScript classes, and even fairly high-level CMS tools
                based just off an application's database schema. 
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-27">
                #27: Know the ingredients of a good code generator</h3>
            <p>
                So, how do you actually write a generator? If you want a truly in-depth source on
                code generation, I recommend Jack Herrington's <em>Code Generation in Action</em>.
                It covers detailed techniques and high-level patterns for generating code of all
                kinds. But, you don't need that level of detail to get started. Here's what you need to know.
            </p>
            <h4>
                Use a programming language with I/O capabilities</h4>
            <p>
                First, you <strong>must</strong> program in a language that can interact with files
                on your machine. Your language of choice must support reading, manipulating,
                writing, and deleting files to disk.
            </p>
            <p>
                Fortunately, pretty much any of today's popular programming languages (C, C++, C#,
                VB, Java, PHP, Python, Ruby, Perl) support this. If you've never read or written
                files using your programming language, spend an hour researching it. Know how
                to read, manipulate, write, save, and delete files. Your code generator will be
                doing a lot of this.
            </p>
            <h4>
                Define your input source</h4>
            <p>
                Second, you need an input source. It's the place that houses all the parameters
                your code generator needs to...generate code. In X2O's case, the input source began
                with an XML file. The XML file defined the data model – it contained nodes for tables,
                fields (and their data types), and foreign keys. It gives the generator all the
                information it needs to create the database, SQL scripts, data access layer, and
                so forth. Here's a example of converting the blog data model into a simple, XML
                input source:
            </p>
            <pre>
&lt;input_source&gt;
    &lt;table name="Posts"&gt;
        &lt;field name="ID" type="int" identity="true" /&gt;
        &lt;field name="Title" type="NVarChar" length="255"/&gt;
        &lt;field name="CreateDate" type="DateTime" /&gt;
        &lt;field name="Body" type="NText" /&gt;
        &lt;foreignkey name="AuthorID" to_table="Authors" /&gt;
    &lt;/table&gt;
    &lt;table name="Authors"&gt;
        &lt;field name="ID" type="int" identity="true" /&gt;
        &lt;field name="FirstName" type="NVarChar" length="255"/&gt;
        &lt;field name="LastName" type="NVarChar" length="255" /&gt;
    &lt;/table&gt;
    &lt;table name="Comments"&gt;
        &lt;field name="ID" type="int" identity="true" /&gt;
        &lt;field name="Comment" type="NText" /&gt;
        &lt;field name="Email" type="NVarChar" length="50" /&gt;
        &lt;field name="CreateDate" type="NText" /&gt;
        &lt;foreignkey name="PostID" to_table="Posts" /&gt;
    &lt;/table&gt;
&lt;/input_source&gt;
</pre>
            <p>
                Over time, your input source will grow. As you find more things to generate, you'll
                likely need more kinds of inputs. For example, when I wanted to generate documentation,
                I added friendly descriptions as attributes to each table and field node. My documentation
                generator could then reference that data to spit out more customized documentation.
                You may want to define the order of each attribute as they appear in a form to generate
                a rudimentary CMS. You can add that attribute to each field node in your input source
                as well.
            </p>
            <p>
                Of course, your input source doesn't have to be an XML file. It can be a text file,
                a database, an RSS feed – it doesn't matter. A year after we began writing X2O,
                we replaced the XML file input with a database. That allowed us to stop manipulating
                XML files and work with an elegant, web-based client instead. Today, our input source
                is just the database that lives underneath the X2O web client.
            </p>
            <h4>
                Extract your input source into something usable</h4>
            <p>
                With input source in-hand, write a program to extract its contents into something
                usable. In my case, we mapped the contents of the XML file into its own object in
                C#. This lets you have both a system that's easy to work with when constructing
                the input source (XML) and a system that's easy to work with when your generating
                code against the input source (like an object in C#).
            </p>
            <p>
                In today's landscape, languages like E4X(ECMAScript for XML) makes converting an
                input source into a programmatic object pretty seamless. Whatever method you use,
                it's critical to have an easy way to loop through and introspect your input source.
                You'll see why in the next step.
            </p>
            <h4>
                Combine your input source provider with templates</h4>
            <p>
                With a usable programming environment and input source defined, the next step is
                to write templates. In our blog example, each tedious part of the development process
                had a formula. For example, to generate all CRUD statements, we do nothing more
                than loop through every table in our data model, and apply the same statements for
                each.
            </p>
            <p>
                Take the CREATE statements. We can take the following bit of real SQL code...
            </p>
            <pre>
CREATE PROCEDURE CreatePost (
    @Title NVARCHAR(255),
    @CreateDate DATETIME,
    @Body NTEXT,
    @AuthorID INT)
AS
INSERT INTO Post VALUES (
    @Title,
    @CreateDate,
    @Body,
    @AuthorID)
</pre>
            <p>
                ...and replace the custom portions with replacable variables...
            </p>
            <pre>
CREATE PROCEDURE Create[cur_table] (
[List_of_attributes_as_input_params]
)
AS
INSERT INTO [cur_table] VALUES (
[List_of_attributes_as_sql_insert_params]
)
</pre>
            <p>
                ...to create a template for generating CREATE statements.
            </p>
            <p>
                With this template, we can loop through each table node in our input source provider
                and fill in the template with the appropriate values. In this case, <span class="code">cur_table</span> is
                just the name of each table, while <span class="code">List_of_attributes_as_input_params</span> and 
                <span class="code">List_of_attributes_as_sql_insert_params</span>
                are found by inspecting the field nodes of the input source provider. We can create
                a <span class="code">CREATE</span> stored procedure for each table in our data model as follows:
            </p>
            <pre>
// This holds our template in memory
string template = file.read("SQLCreate.txt");

// This will hold the final generated output
string output;

foreach (table current_table in input_source)
{
    string cur_table = current_table.Name;
    string p1;
    string p2;

    /* Loop thru each field in the table to create
    List_of_attributes_as_input_params and
    List_of_attributes_as_sql_insert_params */

    foreach (field in current_table)
    {
        p1 += "@" + field.name + " " + field.type.ToUpper() 
           + ",";
        p2 += "@" + field.name + ",";
    }

    // Get rid of the last comma...

    p1 = p1.substring(0,p1.Length – 1); 
    p2 = p2.substring(0,p2.Length – 1);

    // Write the CREATE statement for current table
    output += template.replace("[cur_table]",cur_table]
    .replace("[List_of_attributes_as_input_params]",p1)
    .replace("[List_of_attributes_as_sql_insert_params]",p2);
}

// Write the final output to a file
file.write("my_create_statements.txt", output);

// Assuming the database was already generated, 
// run the SQL file against the database.
</pre>
            <p>
                In pseudocode, the creation of generated code looks like this:
            </p>
            <ol>
                <li>Build an example file for the code you wish to generate.</li>
                <li>Create a template by extracting out the custom parts and replacing them with variables.</li>
                <li>Write code to read in the template file, loop through the input source, and replace
                    the variables from the template file as necessary.</li>
                <li>Write the newly created file to disk.</li>
                <li>Do something with the files at the end (run them, compile them, etc.)</li>
            </ol>
            <h4>
                Component-driven design</h4>
            <p>
                A good rule of thumb: Keep all your generators as separate class files or libraries
                (depending on your programming environment). Early on, X2O was a mass of code in
                one large file. The code that generated the database, SQL scripts, data access layer,
                web services, Flash objects, and CMS files all lived in the same library. While
                it worked, it grew unmanageable. It was harder to maintain because any minor change
                to the generator meant recompiling tens of thousands of lines of code.
            </p>
            <p>
                Once we pulled each part out into about three dozen separate libraries, it was a
                lot easier to maintain. You can then chain all the generators together by referencing
                them in one all-encompassing master generator library.
            </p>
            <p>
                Encapsulating and componentizing is a good programmer habit anyways. But, it's especially
                important when you're building dozens of little generators.
            </p>
            <p>
                With these five simple tips in mind, and plus the aid of a book like Herrington's
                <em>Code Generation in Action</em>, you can get out of the starting gates.
            </p>
            <h4>
                The very first time</h4>
            <p>
                The first time you get your code generator to generate something, I mean <em>anything</em>,
                is thrilling. It feels like your cheating. You've essentially hired a machine that
                will abide by your every word. So, get to that thrill as fast as you can.
            </p>
            <p>
                As I mentioned in <em>Motivation</em>, get your code generator to "launch" as early
                as is achievable. Chew off something <em>small</em> to generate and generate it.
                It might just be generating getter/setter methods for a set of properties in your
                input source. Or, a program that writes data from your input source into an HTML table.
                Find something simple and useful to start – something that will get you excited
                when you realize you never have to write this little bit of code by-hand anymore.
            </p>
            <p>
                When you get that first mini-generator started, motivation will stream through your
                veins.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-28">
                #28: Avoid touching generated code with bare hands</h3>
            <p>
                You can write generators that produce code you intend to modify
                or you can write generators that produce code you'll never actually touch.
            </p>
            <p>
                With X2O, we've made a strict rule that any generated code is not to be modified
                after the fact. Generated code is like fine China...
            </p>
            <h4>
                You break it, you pay for it!
            </h4>
            <p>
                We don't hit the "Generate" button and then noodle around with the freshly generated
                stuff. Why? Suppose we add a new field to our database and want to re-generate
                our new code against an updated data model. Each time we did that, we'd have to
                remind ourselves what we hand-modified and ensure the code is modified again.
            </p>
            <p>
                Code generators that are "one-time only" rarely withstand the test of time. Inevitably,
                something will change in your process or requirements that will force changes to
                what was once generated.
            </p>
            <p>
                If you find yourself needing to noodle around your generated code, there are elegant
                ways around the problem. In C#, you can mark a class as <em>partial</em>. This lets
                you define a class in multiple source files. In X2O, every generated C# class is
                partial, so that, if we ever needed to, we can add any additional methods or properties
                in a separate file marked with the same partial class.
            </p>
            <p>
                If you don't have the luxury of partial classes in your language of choice, there
                are other elegant approaches. You can extend classes, implement interfaces, or write
                custom helper classes. There are all sorts of approaches to take if you find reason
                to modify your generated code.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-29">
                #29: Writing a code generator makes you a better programmer</h3>
            <p>
                Writing your own code generator also makes you think critically about your development
                process. It requires you to figure out
                what parts of your development process are actually repeatable enough to be good
                candidates for code generation. It transitions you from <em>assembly-line
                developer</em> into <em>creative thinker</em>.
            </p>
            <p>That's a healthy practice for programmers. 
            </p>
            <p>
                For example, X2O generates a content management system by introspecting the database.
                There's a one-to-one correspondence between add/edit/listing pages and tables. There's
                a one-to-one correspondence between database field types and input forms. There's
                a one-to-one correspondence between required foreign key constraints and required
                dropdown boxes in an "add" or "edit" screen. 
            </p>
            <p>
                But, there's a balance between how much code you <em>should</em> be generating and how much
                code <em>should</em> be left for custom craftsmanship. After the first few sweet tastes of
                successful code generation, you might feel that air of invincibility and start trying
                to wrap everything into a code generator – even the things that really aren't automatable
                (but certainly tedious).  It's easy to try to cram too much automation into things that
                are still too custom.
            </p>
            <p>
                This is where you really have to consider the benefits of code generation.
                If you're output code requires too many custom inputs to generate or requires
                too many hacks to use, you probably shouldn't be generating that bit in the first
                place. Just like bad code smells, there are also bad code generation smells.
            </p>
            <p>
                Writing code generators gets you thinking about what is truly <em>automatable</em> and tedious
                vs. what is just tedious.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-30">
                #30: Speak, think, and write code in a ubiquitous language</h3>
            <p>
                One incredibly valuable byproduct of code generation is the creation of a ubiquitous
                language. People working on all different areas of the application can speak on the same terms.
                It especially works when you have one centralized model (i.e. a database)
                that spawns off many different generated products. When scripts, code, front-end
                layers and documentation all spawn from the same central source, naming conventions
                become inherently consistent.
            </p>
            <p>
                This means people using any part of the code generator can all speak the same meta
                language. Had people written this by hand, we might see small disparities in language
                convention. A .NET developer might create a class called <span class="code">Person</span> that might
                be pulling data from a database table called users, customers, or employees, even when they
                might correspond exactly one-to-one.
            </p>
            <p>
                Granted, the domain that a middleware developer works in doesn't necessarily map one-to-one with the domain
                that a database designer lives in. But, most web apps today do.  The adherence to similar naming conventions
                across multiple tiers is the philosophical strategy behind web frameworks like <a href="http://www.rubyonrails.org">Ruby on Rails</a> or
                <a href="http://www.djangoproject.com">Django</a>.
            </p>
            <p>
                And even if that's not the case, starting off with the same conventions
                in nomenclature from the get-go (and then breaking convention as it makes sense),
                sidesteps some of the common inefficiencies in team development. Where models can
                translate from one tier to another, you ought to stick to the same naming convention.
                And, a code generator can enforce that.
            </p>
            <p>
                A ubiquitous language means that all stakeholders talk about the same application
                in the same vernacular, instead of letting technological disconnects stand in the
                way.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-31">
                #31: Generated code makes errors obvious and small modifications powerful</h3>
            <p>
                Writing your own code generator might seem like a lot more extra work at first.
                You're always one step removed from the actual production code. There's something slightly
                less tactile about the process – it feels like writing code with latex gloves on.
                But, once you get over that initial awkwardness, you'll find that writing code that
                writes code is actually easier at times.
            </p>
            <p>
                Debugging is a perfect example. If something in your generated code isn't working
                right, the errors will become obvious. The same error will repeat itself <em>over and over again</em>,
                in the <em>exact same</em> fashion. Remember, it's your code that's writing the
                real production code, not a fallible human being. It's much easier to spot what's
                wrong when things are wrong in the exact same way, each time.
            </p>
            <p>
                Compare this to a developer that makes the occasional sloppy, lazy coding mistake.  It happens to 
                the most diligent of us.  A code generator makes debugging easier
                because there will be a consistency to the errors being made. And, once you've found
                the source of the problem, you make a tweak, re-run your generator, and replace the problem
                throughout your outputted code, all at once.
            </p>
            <p>
                In code generation, errors are obvious and small tweaks are powerful.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-32">
                #32: Address the naysayers</h3>
            <p>
                There are many out there that scoff at code generation. They say it creates bad
                habits and bad architecture. While this can be true, it's a human problem. You're
                in complete control to avoid these problems.
            </p>
            <p>
                Some argue that code generation is a trade-off between rapid output and custom-fit
                code &mdash; it creates a lot of excess that rarely gets used by the end application.
                Because it's so easy for programs to write code, you may not care as much to have
                it generate concise, optimized code. But, this is something easily resolved.
            </p>
            <p>
                Perhaps your next project doesn't need a certain set of data access methods. Use
                your input source to define some optional parameters so that you're not spitting
                out sheets of excess code for a project that doesn't need it. As your generator
                matures, you might want to enable and disable certain code from generating. This
                is where component-driven design really helps.
            </p>
            <p>
                Some argue that code generators produce inelegant code. Blasphemy! This has nothing
                to do with code generators and everything to do with how you prescribe what your
                code generator should produce.
            </p>
            <p>
                If your generated classes have duplicate functions or common methods, then refactor
                the templates that make up your code generator. Write the duplicate functions into
                a stand-alone class that live outside the generator. Write an interface and let
                each generated class implement it. You can still apply the same programming-by-hand
                techniques to your generated code.
            </p>
            <p>
                When we code by hand, we usually follow this heuristic:
            </p>
            <ol>
                <li>Make the code compile</li>
                <li>Make the code do what we claim it should do</li>
                <li>A long while later, refactor it so it's easier to maintain.</li>
            </ol>
            <p>
                What's the number one reason we refactor code we write by hand? It makes the code
                easier to maintain in the future. That's why it's hard to motivate yourself to refactor
                generated code – you never need to actually <em>maintain</em> the code you generate.
                You only maintain the generator.
            </p>
            <p>
                But, there is nothing that says your code generator can't follow good principles.
                If your generated code repeats the same methods 30 times in 30 different classes
                then, modify your generator so those methods live in a class that can be inherited
                by the other 30 generated classes. Apply the standards you adhere to when you write
                code manually into the code you generate. Resist the temptation to take shortcuts
                in your outputted code.
            </p>
            <p>
                In addition, some argue that generated code makes your applications inflexible.
                They have to conform to whatever framework the generated code has imposed on you.
                Here, the onus is on you. If your generated code forces limitations on your end-applications,
                you may need to reconsider whether you're generating the <em>right</em> things.
            </p>
            <p>
                It's tempting to push more of your work off to building a code generator, even at
                the expense of the end-application. Know where to draw the line between work that's
                automatable from work that you really should be doing yourself each time.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-33">
                #33: Automating software is not like fast-food</h3>
            <p>
                The best pizzerias in the world, the ones you hear your friends and self-proclaimed
                TV food aficionados rave about, make their pizzas by hand, in-house. But, suppose
                one day your favorite pizza place fired the chefs and replaced them with an assembly
                line of machines. Each machine is in charge of building different parts of the pie
                – the dough pounder, the sauce layer, the cheese topper, the mushroom dispenser,
                and the perfectly timed oven. You could build machines to automate the construction
                of a pizza, and it would be perfect each time.
            </p>
            <p>
                If measured by precision, machines ought to do a far better job than human pizza
                makers. They'd surely be more consistent and faster. Although consistency and expediency
                are huge components to a restaurant's success, the restaurant still might lose business.
            </p>
            <p>
                While consistent quality is a key component to a good pizza, there's value in the
                handcrafted nature of pizza. A handmade pizza is shaped slightly differently each
                time. Certain ingredients might be fresher this week than last. There are desirable
                burnt edges here or there. The imprecise cutting of the pie usually creates a few
                guilt-free mini slices ("Oh, I'll just have this little one here"). The organic
                nature of handmade pizza has value to the consumer.
            </p>
            <p>
                Whether it's our curse or our good fortune, building the <em>algorithmic</em> parts
                of software by hand adds no intrinsic value to the product. It's simply not a selling
                point. As much as you enjoy the building of software, consumers don't care. The
                public doesn't crave inconsistent bits of handmade software &mdash; they want the very
                opposite. Automating that-which-can-be-automated saves us time and energy to focus
                on those parts which aren't automatable and require more delicate thought without
                the drawbacks you might find in industries like the food industry.
            </p>
            <p>
                Back in the 1950s and 1960s, fast food was hip. It was the future of food &mdash; that which showed
                the might of American ingenuity. It fit the lifestyle of a nation who predominantly
                travelled by automobile and wanted a quick, yet still satisfying way to enjoy food
                "on-the-go."
            </p>
            <p>
                Yet, a few decades later, that mystical magic food began to backfire. The quasi-automated
                nature of making such food led to major problems in our society. Fast-food culture
                has produced a major obesity epidemic due to the non-natural content of the food,
                health-care scares due to the things we feed our animals and the pesticides we spray
                to mass produce crops. And besides all of the social, environmental, and moral benefits,
                a culture simply fell back in love with <em>real hand-crafted food</em>.
            </p>
            <p>
                Fortunately, we don't have that problem with "fast code."
            </p>
            <p>
                While we love thoughtful software, we can still mass produce the algorithmic bits
                with the same quality of code as if we crafted it manually. There's no gain in typing
                code by-hand that can more quickly and more accurately be generated.
            </p>
            <p>
                That's why we <em>ought</em> to build our automated dough pounders, sauce layers,
                and cheese toppers in our software when and where we can. It gives us more time
                to craft the custom parts of our software &mdash; the parts that require more human thought
                and craftsmanship. Automating, where applicable, makes our software better, at no
                loss to the consumer.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h2 id="complexity">
                Complexity
            </h2>
            <p>
                Aside from death and taxes, complexity may be the only other sure bet in life. Complexity
                always grows over time. In our industry, it's the unavoidable consequence of maturing
                software. Unless you're willing to remove features, there is simply no way to sidestep
                it.
            </p>
           <p>
                If you can't get rid of complexity, your next job is to stifle its growth.  Recognize when complexity <em>isn't</em>
                necessary. Develop a finely tuned nose for it. When you know what it
                smells like, you can pick up the all-to-familiar stench from every nook and cranny
                of your software. You'll be better off in the end.
            </p>
            <div class="cartoon">
                <img src="http://www.andertoons.com/img/cartoons/5710.jpg"/>
            </div>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-34">
                #34: Snuffing out bad complexity</h3>
            <p>
                Bad complexity is complexity that just <em>doesn't have to be there</em>. And it's
                not always easy to spot. Sometimes, even the pieces we think have to be there really
                do not.
            </p>
            <p>
                In 1776, Thomas Jefferson sat on the committee that drafted the Declaration of Independence.
                The committee gave Jefferson the privilege of writing the first draft. When the
                draft was completed, he sent it to his friend, Benjamin Franklin for review. His
                draft was returned with much of Jefferson's handiwork erased or severely reduced.
            </p>
            <p>
                Jefferson was none to happy, but Franklin tried to convince his friend why this
                was for the better. As Congress analyzed the draft, Jefferson recounted the story
                that Franklin had told him:
            </p>
            <blockquote>
                <p>
                    "When I was a journeyman printer, one of my companions, an apprentice hatter, having
                    served out his time, was about to open shop for himself.
                </p>
                <p>
                    His first concern was to have a handsome signboard, with a proper inscription. He
                    composed it in these words:
                </p>
                <p class="center">
                    John Thompson,<br />
                    Hatter,<br />
                    makes and sells hats<br />
                    for ready money
                </p>
                <p>
                    with a figure of a hat subjoined; but he thought he would submit it to his friends
                    for their amendments.
                </p>
                <p>
                    The first he showed it to thought the word 'Hatter' tautologous, because followed
                    by the words 'makes hats,' which showed he was a hatter. It was struck out.
                </p>
                <p>
                    The next observed that the word 'makes' might as well be omitted, because his customers
                    would not care who made the hats. If good and to their mind, they would buy them,
                    by whomsoever made. He struck it out.
                </p>
                <p>
                    A third said he thought the words 'for ready money' were useless, as it was not
                    the custom of the place to sell on credit. Every one who purchased expected to pay.
                    They were parted with, and the inscription now stood, 'John Thompson sells hats.'
                </p>
                <p>
                    'Sells hats!' says the next friend. 'Why, nobody will expect you to give them away.
                    What then is the use of that word?' It was stricken out, and 'hats' followed it,
                    as there was one painted on the board.
                </p>
                <p>
                    So the inscription was reduced ultimately to 'John Thompson,' with the figure of
                    a hat subjoined."
                </p>
                <p class="footnote">
                    Courtesy: <a href="http://www.pbs.org/benfranklin/l3_citizen_founding.html">PBS.org</a>
                </p>
            </blockquote>
            <p>
                Plenty of software could take a cue from the hatter's sign. Does this button need
                to be there? Is this line of copy adding anything of value, or is it merely repeating
                something else that's already there? Does this new feature actually help make the
                task easier?
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-35">
                #35: The simplicity paradox</h3>
            <p>
                Here's the maddening thing: <em>Everyone.</em> <em>Loves.</em> <em>Simple.</em> That's why people say "I just want
                things to be simple." Who says "I just want things to be complicated"...<em>ever</em>?
            </p>
            <p>
                I decided to find out.
            </p>
            <p>
                As of this writing, if you Google the phrase "I want things to be simple," you'll
                get approximately 954,000 matching results. There is <strong>one</strong>
                unique matching results for the phrase "I want things to be complicated."
            </p>
            <p> <strong>One</strong>.
                The only unique matching result? My company blog post that I wrote about this very
                subject in October, 2009.  Extract myself out of the annals of recorded human civilization, and, apparently,
                no one has ever wanted, or even mused the idea of voluntary complication.
            </p>
            <p>
                Then, why do we run into this Jeffersonian problem of complexity when we're building our own stuff, so often? 
                Why do the things we produce often wind up festered in complication? How do so
                many well-intentioned pieces of software matriculate from simple idea to functional
                nightmare?
            </p>
            <h4>Sometimes it's because simple products are, quite simply, hard to build</h4>
            <p>
                Most ideas, simple at the surface, are viciously complicated when you
                get into the details. Because ideas, at a high-level, are always simple. Every business idea
                must be accompanied by the elevator pitch &mdash; 60 seconds to get the message across
                from beginning to end. You can't pack complexity into a 60-second description.
            </p>
            <p>
                When ideas start feeling complex, you've left the comforts of Idealand and actually
                started thinking about the implementation. Once you dig into the details, you discover new states,
                edge cases, and question marks. It's the nature of <em>detail</em>.
                An idea that hasn't been thought through completely (read: most of them) has little
                chance of surviving Complexityville at this point. Rather than rethinking the idea
                altogether, it's sometimes easier to plow through the problems with head down and blinders
                up. Half-baked decisions are made; features are added all for the sake of sparing
                the sanctity of the "Big Idea." Then, complexity festers.
            </p>
            <h4>
                But, not all simple things are hard to build.  
            </h4>
            <p>
                If everyone likes simple, and not all simple things are simple to build, you'd think that most software
                should be both simple-to-use and simple-to-build.  It's a win-win for both user and developer.  But, that kind
                of software rarely exists in our world. There has to be something more to this mystery.
            </p>
            <p>
                 More often than not, simplicity is lost, because, when you build something simple,
                 it just doesn't feel like it's <em>enough</em>. You mislead yourself into believing your customer isn't getting his money's worth. 
                 A simple thing that's <em>also</em>
                simple to build feels value-less. An idea that's easily implemented is rarely considered
                a "big idea" at all. Truly simple ideas seem inferior; if it's simple to build,
                it must not be a good idea.
            </p>
            <p>
                Businessmen, venture capitalists, and angel investors don't throw millions of dollars at 
                simple ideas. They throw money at the Donald Trump superlatives &mdash; innovative, cool, cutting-edge, best-in-class.  
                Often times, these are just other ways of saying an idea is <em>complex</em> enough to be
                worth its weight.
            </p>
            <p>
                Herein lies the paradox. From a builders point of view, we often equate the worth
                of the software we build to its complexity. More complexity equals more value. Even
                when we've all agreed to build something simple, inevitably, our fear of inadequacy
                leads us to something more complex.
            </p>
            <p>
                The view from the other side of the mirror is a bit different. The reality is, 90%
                of the world uses only 10% of the features built in the average enterprise-level
                software. When users can't find the few functions they need because they're buried
                amongst the many features they don't need, they either take it out on our own perceived
                shortcomings or blame it on the software itself. Users see complexity as the shortcoming;
                builders, marketers, and stakeholders see simplicity as the shortcoming.
            </p>
            <p>
                Standing behind something simple feels too easy and too cheap. But, we forget that
                the real end-user often has different parameters for success.
            </p>
            <p>
                At <a href="http://www.wearemammoth.com">We Are Mammoth</a>, the natural urge to complicate is something we resist constantly in
                our business. We have to re-sell and re-pitch simple to ourselves each time.
            </p>
            <p>
                Countless internal arguments about features in our own software end up with incredibly
                simple solutions &mdash; changes in text, moving a link somewhere else on the page, removing
                something, or deciding the new feature just wasn't worth it to begin with. Yet, these simple conclusions
                came out of hours and days of discussion, thinking, and re-thinking.
            </p>
            <p>
                It's natural to feel that the amount of time you spend on something should parallel
                the amount of measurable output you put into the product, regardless of the benefit
                of that new feature. But, free yourself from that debilitating thought. Once you've
                let go of the vulnerable feeling that simplicity cheapens your worth, you can finally
                get on with building good software.
            </p>
            <p>
                Simplicity empowers. It is one reason why experts keep doing the things they excel
                at – because those things come more naturally (read: simply) to them than to the
                masses. We crave things that make sense, have rules, boundaries, and reasonable
                expectations. It lets us wrap our head around a problem completely. Simplicity is
                not boring – it's comforting. Simplicity is timeless.
            </p>
            <p>
                A simple solution shouldn't be thought of as "not enough" of anything. Sometimes
                it is exactly enough of everything.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-36">
                #36: Complexity as a game of pick-up sticks</h3>
            <p>
                Software sometimes feels a lot like <em>Pick-up sticks</em>: the children's game
                where you try to remove individual plastic sticks from a pile without disturbing
                the others. You start the game by holding a bundle in your hand and letting them
                go. Most of the sticks fall in a pile in the middle, while a select few roll their
                way away from the center.
            </p>
            <p>
                Each stick represents a feature. Sometimes, a feature just lives outside the whole
                mess of others. Sometimes, it touches a few components. Sometimes it's completely
                entwined around everything else.
            </p>
            <p>
                Implementing a new feature is like adding a few new sticks into the mix. At a certain
                point, trying to remove any stick without disturbing the rest is nearly impossible.
                Complexity adds up fast. We try our best to circumvent this by following good habits
                – encapsulating, scoping variables at the right level, breaking apart larger pieces
                of logic into bite-size chunks, introducing patterns. It's our way of aligning the
                sticks in parallel, side-by-side, so they don't touch each other. But, consistently
                refactoring code into the "right" places while continuing to add more sticks into
                the mix can get hairy. It's easy to let your guard down.
            </p>
            <p>
                Every time you add a new feature, you stand the chance of disrupting a host of other
                features that might not at first seem directly connected. As you add more features,
                those disruption points grow pretty rapidly.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-37">
                #37: Complexity under the surface != Complexity at the surface</h3>
            <p>
                "An extraordinarily complex mess."
            </p>
            <p>
                That's what Nina Olson, the national Taxpayer Advocate for the U.S. Internal Revenue Service calls the American tax system.
                The official book weighs in at about 6,500 pages.  Can you imagine?  If you think I'm lying, you're right.  It's actually 
                about <strong>65,000</strong> pages long.
            </p>
            <div class="cartoon">
                <img src="http://www.andertoons.com/img/cartoons/2110.jpg"/>
            </div>
            <p>
                This is why I love <a href="http://www.turbotax.com">TurboTax<sup>&reg;</sup></a>.  It's taken these 65,000 pages of
                documentation and miraculously curated some sort of usable software out of it, for commoners like me.  TurboTax<sup>&reg;</sup> could
                so easily have just reproduced the Federal and State 1040 Forms digitally, turning each line item into a text field, calculating
                a few fields here and there, <em>gratis</em>, submitted the form for you via the Information Superhighway and be done with it. 
            </p>
            <p>
                It probably still would have a lot of fans.
            </p>
            <p>
                Instead, TurboTax<sup>&reg;</sup> is like a personal tax wizard who understands that no one really wants to hang out with it.    
                "Get your W-2 out and copy the numbers into me."  "Do you own a farm? No?!  Then let's
                not ever mention it again."  It even knows when it's asking me esoteric questions, by letting me know that something is
                very unlikely or uncommon. "This probably doesn't apply to you."
            </p>
             <p>
                TurboTax<sup>&reg;</sup> has done a heroic job of making tax filing, at least, palatable.  I can only imagine what a stinky mess the underlying code
                must be.  Logic not just for federal law, but for each of the fifty states, and for each of the thousands of local
                counties and beyond.  And within those parameters, logic for single and married people, small-business owners, investors, students, 
                philanthropists, first-time home buyers, the unemployed, the just-retired, the forgetful, the poor, the rich, the richer,
                and &mdash; yes, farmers.
             </p>
             <p>
                Couple that with the annual changes to tax laws &mdash; every little rule taken out or put in to account for some earmark in government
                spending that make up those 65,000 pages of dead trees.  If you think you're angry about a couple extra hundred dollars you owe the government, imagine being a TurboTax<sup>&reg;</sup> developer
                writing yet another weird bit of conditional logic for someone who's just bought an environmentally-friendly motorboat in Mississippi 
                within the last six months.  
             </p>
             <p>
                Is any of that code even worth refactoring?  What would you refactor, when the very code you're writing today might be obselete after the
                next Congressional recess, or might depend on a totally different set of parameters down the road?
             </p>
             <p>
                TurboTax<sup>&reg;</sup> is proof that, even when the task at hand is an <em>extraordinarily complex mess</em>, the software itself doesn't have to be. 
                You can squeeeze all that complexity underneath the surface, interpret that mess into some reasonably digestable set of usable functions,
                and create some really helpful, far more simplistic, software.
             </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-38">
                #38: Hard to code might mean hard to use</h3>
            <p>
                TurboTax<sup>&reg;</sup> takes something nearly impossible to comprehend, and makes it approachable 
                to the masses.  Complexity is shifted from the user to the code. 
            </p>
            <p>
                However, not always is this shift a zero-sum game.  Sometimes, overly complex logic is just a sign that
                the function of the application is confusing.  Complex code supporting a complex interface?
                How about we don't.
            </p>
            
            <h4>
                Confusion in the elevator</h4>
            <p>
                Back in Lesson #23 ("Write Code as a Last Resort"), I mentioned one of my favorite
                anecdotes &mdash; the story of the poorly-performing New York City elevators. Let's propose
                a similar problem. Instead of the tenants complaining about waiting at the elevator
                lobby, suppose they're now bickering about how long it takes to let each person off the elevator. 
            </p>
            <p>
                "Listen to the young psychologist! Put mirrors <em>in</em> the elevator!" you cry.
            </p>
            <p>
                Yes, that might do the trick.  But, that approach seems too simple. Instead, let's try to
                change the way the elevator lets people off the elevator.  
                An elevator typically goes in one direction all the way until there aren't anymore requested 
                floors in that direction. Is there a better way than the 
                common algorithm?
            </p>
            <p>
            </p>
            <div class="cartoon">
                <img src="http://www.andertoons.com/img/cartoons/5521.jpg"/>
            </div>
            <p>
                Imagine you're part of a team of engineers attempting to build better software to control an elevator
                for a 50-story high-rise. The elevator can monitor what floor people enter and which
                floor button they press. Your manager (The Idea Guy) walks in with one, simple commandment:
            </p>
            <blockquote>
                <p>
                    "Build the elevator so that people collectively spend the least amount of time on it!" &mdash; The Idea Guy.
                </p>
            </blockquote>
            <p>
                A seemingly simple goal, your team starts running through the scenarios.  Suppose John steps in from the ground floor and 
                pushes the button to go to his penthouse
                on floor 50. The elevator goes up but stops at Floor 8. In comes Steve, the UPS
                delivery guy, with a large brown box. He has to deliver the package to Floor 5, so,
                he quickly presses "5".
            </p>
            <p>
                What should the elevator do? Should the elevator stop at 5 first, because it's closer,
                or stop at 5 second because it's already heading north?  A typical elevator keeps going up.
            </p>
            <p>
                But, this isn't a typical elevator.
                This new state-of-the-art elevator will go in whatever direction gets everyone off
                the fastest. 
            </p>
            <p>
                Using this metric as our end goal, the engineers agree that the
                elevator should come back down to floor 5 first. If the elevator heads back down
                to 5, John and Steve will pass a total of 59 floors:
            </p>
            <p>
                John: 8 up + 3 down + 45 up = 56 floors passed.
            </p>
            <p>
                Steve: 3 down = 3 floors passed.
            </p>
            <p>
                Total floors spent by John and Steve: <strong>59</strong>.
            </p>
            <p>
                Compare this to the alternative. If the elevator, instead, keeps going up, before
                coming back down to floor 5, they'd collectively pass more than twice that many:
            </p>
            <p>
                John: 50 up = 50 floors passed.
            </p>
            <p>
                Steve: 42 up + 45 down = 87 floors passed.
            </p>
            <p>
                Total floors spent by John and Steve: <strong>137</strong>.
            </p>
            <p>
                Now, let's tweak the scenario a bit. Suppose Steve, the UPS delivery guy, had entered
                the elevator at floor 30, instead of floor 8.
                Here's what happens if the elevator comes back down first:
            </p>
            <p>
                John: 30 up + 25 down + 45 up = 100 floors passed.
            </p>
            <p>
                Steve: 25 down = 25 floors passed.
            </p>
            <p>
                Total floors spent by John and Steve: <strong>125</strong>.
            </p>
            <p>
                And if, instead, the elevator kept going up to John's penthouse before coming back
                down:
            </p>
            <p>
                John: 50 up = 50 floors passed.
            </p>
            <p>
                Steve: 20 up + 45 down = 65 floors passed.
            </p>
            <p>
                Total floors spent by John and Steve: <strong>115</strong>.
            </p>
            <p>
                In this scenario, we save 10 "man" floors if the elevator goes up! So, depending
                on when Steve gets on, the elevator may decide to continue its ascent or descend
                first before re-ascending.
            </p>
            <p>
                Programming for the optimal elevator ride for two people is pretty benign. 
            </p>
            <p>
                But, suppose a third person, Samantha, enters the elevator. Now, we need to calculate
                six scenarios. Think of the problem more simply as, what order should the elevator
                deliver the three passengers?
            </p>
            <ul>
                <li>Case 1: John, Steve, Samantha</li>
                <li>Case 2: John, Samantha, Steve</li>
                <li>Case 3: Steve, John, Samantha</li>
                <li>Case 4: Steve, Samantha, John</li>
                <li>Case 5: Samantha, Steve, John</li>
                <li>Case 6: Samantha, John, Steve</li>
            </ul>
            <p>
                In fact, the number of scenarios that need to be tested is just the factorial of
                the number of people on the elevator at a given time:
            </p>
            <code>
                2 people = 2! = 2 comparisons<br />
                3 people = 3! = 6 comparisons<br /> 
                4 people = 4! = 24 comparisons<br /> 
                8 people = 8! = 40,320 comparisons </code>
            <p>
                Once we get past just a few people, the number of cases to test becomes impractical.
            </p>
            <p>
                But, that's only <em>one</em> aspect of the complexity problem. People are getting on 
                and off the elevator at different times. Each time a new
                person enters the elevator, we would need to keep track of how many floors the existing
                passengers have already passed before attempting the new set of calculations.  
            </p>
            <p>
                In other words, we couldn't sufficiently deduce the path the elevator has already
                taken just by looking at who's currently on-board. If Mike enters on Floor 25, then Sanjay
                enters at Floor 35, did the elevator travel 10 floors between Mike's entrance and
                Sanjay's, or did it go back to Floor 21 first to drop off Samantha? 
            </p>
            <p>
                At more than two elevator-riders, we'd <em>also</em> need to track when people leave
                the elevator so we can omit them from future calculations.
            </p>
            <p>
                And, what happens when someone forgets to hit their floor number, or hits the wrong
                floor number and then presses a button during mid-ascent? Does our software recalculate
                and potentially shift gears in mid-flight?
            </p>
            <p>
                If you are new to programming, this is, sadly, not an exaggerated example of how
                complex a seemingly simple goal (like getting people off an elevator as quickly
                as possible) can be.
            </p>
            <h4>Complexity with little pay-off</h4>
            <p>
                Suppose, somehow, you've built the perfect system. Your team has managed to write code
                in such a way that everyone collectively leaves the elevator in the shortest amount
                of time &mdash; calculating thousands of scenarios in a split-second, taking into
                account everyone's already-taken-path. It's a true feat of technology! But, how
                are John, Steve, and the rest of the gang faring?  
            </p>
            <p>
                Code is great at the tediously automatable. And, this
                is certainly a case of the extraordinarily tedious. But, humans aren't good at it.
                John and Steve are at the complete mercy of the elevator, not knowing which general
                direction they'll be going when the next person gets on, nor why.
            </p>
            <p>
                Here we have a case where <em>hard to code means hard to use</em>. Complexity, in
                this case, hurts <em>both</em> ways. By the time even a fourth person gets on the
                elevator, there are just too many scenarios for a human to know what route the elevator
                wants to take. Even when the elevator is accomplishing the goal of "get everyone
                off in the fewest amount of collectively traveled floors," the people inside are
                left wondering when it's their turn.
            </p>
            <p>
                They might well prefer a couple of simpler solutions like:
            </p>
            <ul>
                <li>The elevator's path goes in the order each floor was selected</li>
                <li>The elevator goes all the way up first before coming all the way down</li>
            </ul>
            <p>
                Sure, we might not reach the optimal path, but, by favoring a simpler solution, the people
                in the elevator have better knowledge of what's going on from the outside. And, sometimes,
                that's more important than anything else.
            </p>
            <p>
                When details become egregiously hard to code, it <em>may</em> be a smell that the
                actual function of the system is difficult to understand. And, while you may pat
                yourself on the back that you've programmed something inherently complex, others
                are punching you <em>in</em> the back.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-39">
                #39: Design patterns and the danger of anticipation</h3>
            <p>
                Another smell of complexity arises when we think too far ahead in our code. There's
                a price to pay for being too cute or too cerebral about the actual thing you're
                trying to build. A classic case &mdash; implementing a design pattern too early.
            </p>
            <p>
                Don't get me wrong. Design patterns are wonderful things. When a common programming
                approach happens over and over again, we get excited. We've all experienced it –
                that sense your code could be doing something <em>greater</em> than just solving
                the concrete task-at-hand. That feeling you've solved a problem you didn't even
                realize you were working on.
            </p>
            <p>
                When you've had this feeling a few times, successfully architecting your code to
                more abstract patterns, it's easy to feel invincible. You work like a crime dog,
                sniffing out any small sign or clue, any hint, even false ones, that another abstraction
                lives above your straightforward piece of code.
            </p>
            <p>
                But, very quickly, your sixth sense can come back to bite you where it really hurts.
                Most of us have heard, or experienced, the horror stories of "architecting yourself
                into a corner." It's where you've taken an approach to solve a problem in a more
                abstract way.
            </p>
            <p>
                For example, you're working on an intranet for Burgeoning Web Company. They're small
                – they only have two departments – IT and sales. They want the ability to calculate
                anticipated bonuses for their employees based on a bunch of employee parameters.
                But, each department wants to emphasize different things.
            </p>
            <p>
                The IT department only wants to give bonuses to employees that have stuck around
                for 5 years, and as a percentage of their current salary. The sales department wants
                to give everyone a base bonus, plus a standard incremental bonus for each year they've
                worked at Burgeoning Web Company. The execs are generous folk.
            </p>
            <p>
                You start coding. You've built out an <span class="code">Employee</span> class that will contain all the information
                you need to calculate an employee's bonus. You then write a simple function, which, for now, 
                contains one simple conditional statement to return a given
                employee's anticipated bonus.
            </p>
            <pre>
public decimal GetBonusForEmployee(Employee employee)
{
    if (employee.department == Departments.IT)
    {
        // Calculate bonus the "IT" way
        if (employee.Years &gt;= 5)
        {
            return .1 * employee.Salary;
        }
        
        return 0;
    }
    else
    {
        // Calculate bonus the "Sales" way
        return 1000 + 500 * employee.Years;
    }
}
</pre>
            <p>
                You write a little tool to load all employees into a collection of <span class="code">Employee</span> objects,
                and then apply the method above to each.  Your work is done.  Beer time.
            </p>
            <p>
                But, your mind begins to think ahead to the other possibilities that lie ahead when
                Burgeoning Web Company really begins to...burgeon. What do I do when the third or
                fourth department comes along? Swap the conditional for a switch statement! But,
                why wait now. Let's anticipate it now so we're ready for the future:
            </p>
            <pre>
public decimal getBonusForEmployee(Employee employee)
{
    switch(employee.department)
    {
        case Departments.IT:
        
            // Calculate bonus the "IT" way
            if (employee.Years &gt;= 5)
            {
                return .1 * employee.Salary;
            }

            return 0;

        case Departments.SALES:
        
            //Calculate bonus the "Sales" way
            return 1000 + 500 * employee.Years;
    }
}
</pre>
            <p>
                Beautifully done! The switch statement is a safe, elegant, anticipatory move. It
                explicitly identifies the Sales department instead of relegating it to the <span class="code">else</span>
                statement. When Marketing comes along, you know just where it fits. The change from
                conditional to switch statement is a good one.
            </p>
            <p>
                This small refactoring makes sense. Our code is now more explicit. It's easier to
                scan. Another developer could come in and pick it up right away.
            </p>
            <h4>Is it good enough for now?</h4>
            <p>
                Sensing your higher calling, you decide to do more. What happens when two departments
                becomes....10? There's HR, Legal, Production, Accounting, the Janitorial staff.
                <em>It's gonna happen</em>. The switch statement is going to eventually get unwieldy. It will
                be tainted with complex calculations that just have no business lying there, exposed so nakedly
                at the surface of the bonus calculation method.
            </p>
            <p>
                You rifle through your Patterns book (I do recommend <a href="http://www.amazon.com/Refactoring-Patterns-Joshua-Kerievsky/dp/0321213351">this 
                one</a>) and, voila &mdash; the strategy pattern! Move all those
                one-off bonus calculations into individual strategy classes (e.g. <span class="code">ITBonusCalculationStrategy</span>
                and <span class="code">SalesBonusCalculationStrategy</span>) that each implement a Bonus Calculation Strategy interface
                (<span class="code">IBonusCalculationStrategy</span>).  This interface will require each implementing class to define
                a <span class="code">CalculateBonus()</span> method.
            </p>
            <p>
                Once that's done, you modify the <span class="code">Employee</span>
                class to contain a concrete strategy instance, and create one new public method that will
                return the employee's bonus.
            </p>
            <p>
                With the strategy pattern, you can now remove the <span class="code">getBonusForEmployee()</span> method altogether.
                The calculation of an employee's bonus can now live in the class itself. Now, all those nasty algorithms 
                lie elegantly in the soft cushiony pillows
                of individual implementations of the <span class="code">IBonusCalculationStrategy</span> interface.
            </p>
            <p>
                And, since you've gone this far, you decide to embellish your code further. You
                abstract the creation of employees into a factory pattern. This way, you can create
                department-specific employee creator classes that can assign an employee's corresponding
                bonus strategy.
            </p>
            <p>
                You've completely removed the conditional switch on departments (it's taken care
                of in the employee creator classes), and the nasty calculation logic (it's buried
                in department-specific strategy classes). Wonderful!
            </p>
            <p>
                Once department #15 comes along, this architecture will be a site to see.
            </p>
            <p>
                Weeks and months go by. The winter hits, and times are tough for Burgeoning Company.
                No new departments. Meanwhile, the bonus logic has changed. You go back in, stepping
                through code, wondering, where the
                #$&amp;*#&amp;$ is my simple logic? Ah yes. It's been strategized and factory-ized.
            </p>
            <p>
                Another couple months go by. Burgeoning Company calls and says, they've fired the
                sales team, and it'll just be the CEO working the phone with his team of developers.
                Wanting to keep developer morale, the CEO still wants to offer bonuses, but, now
                based solely on seniority.
            </p>
            <p>
                It's time to shed a tear. You've placed all your bets
                on department-specific bonus rules. It was, by all accounts, a safe one a year ago.
                You built the walls, ladders, and slides to account for every possible department
                bonus for the next hundred years. And here, the entire refactoring has gone to waste.
                It's not just over-architected clutter, its spoiled clutter. You unearth your strategy
                classes, remove the factory methods, and submissively decide that, a potentially-nasty-but-currently-quite-alright
                conditional statement will do just fine for now.
            </p>
            <p>
                Patterns are wonderful concepts.  But, they should be implmented with the utmost caution. Anticipating
                logic in the future, more often than not, leads to unintended complexity.
            </p>
            <p>
                If there is a golden rule, it's that an application shouldn't be forced into a well-documented
                design pattern or set of patterns. Rather, a design pattern (or set of them) should
                be implemented as fully as needed to fit the desired tasks of the application, and
                the most likely scenarios for the near future.
            </p>
            <p>
                When you study a design pattern, read it as a general approach to solving a particular
                problem, not as a strict, rigid solution to a problem. Patterns all have pros and
                cons. While patterns make some tasks more elegant to perform, you always lose something
                else. And, since most of today's web applications are constantly changing based
                on new customer or client requirements, finding the "perfect" set of patterns from
                the get-go is more dream than reality.
            </p>
            <p>
                Does this mean you shouldn't anticipate at all? No. The same problems manifest when
                you don't pay any attention to where your architecture is headed.
            </p>
            <p>
                Examine any code-base whose authors decided not to make simple refactorings. The
                problems reveal themselves quickly. Variables are scoped at the wrong level, or
                even worse, accessible globally with some bizarre naming convention to ensure they'll
                always be unique. Conditional logic reads more like the terms on a Terms of Use
                page – a bunch of unrelated truths stitched together with <em>ands</em> and <em>ors</em>
                that have collectively lost all meaning to the next unlucky soul that has to modify
                it.
            </p>
            <p>
                You'll find this often in legacy code in larger companies – code that's been handed
                down from generation-to-generation of developers that came into it without much
                passion and came out of it with even less. Method signatures become unruly, and
                method calls look like the code itself isn't sure what you're doing:
            </p>
            <code>calculateBonusesForTeam(.02, 155000, null, 0, 0, null, new Employee(), null, null,
                false, true); </code>
            <p>
                Over time, unconsidered refactorings get expensive. Maintenance becomes asymptotically
                slower. Forget big changes &mdash; even small changes, the ones you always take for granted,
                might collapse a code base that's long since forgotten any basic set of good habits.
                This kind of code gels into a sticky molasses.
            </p>
            <p>
                Back to the Burgeoning Company story, at some point, refactoring the bonus calculations
                into a strategy pattern might have made sense. Moving employee creation methods
                into a factory class might have been useful. <em>It just wasn't at the
                time.</em>
            </p>
            <p>
                Over-architect too early in the development life-cycle, and you're left with a hole
                waiting to be filled. Under-architect and you're left without any option or motivation
                to evolve your software any further.
            </p>
            <blockquote>
                <p>"The hole and the patch should be commensurate." <em>-Thomas Jefferson to James Madison
                </em>
                </p>
            </blockquote>
            <p>
                Perhaps, Jefferson was channeling his conversation with Benjamin Franklin a few
                years earlier.
            </p>
            <p>
                Refactoring to patterns is incredibly powerful.  But, it really depends on when. I highly
                recommend Joshua Kerievsky's book, aptly named "Refactoring to Patterns." It discusses
                when, why, and how to refactor code into (and also, out of) common software patterns
                far better than I could ever do.
            </p>
            <p>
                Anticipate, but anticipate cautiously. Whether it's just a small change or a large
                pattern shift, know what your gaining and losing each time you decide to refactor.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-40">
                #40: Programming Cadence</h3>
            <p>
                So, how do you manage anticipating too early to change vs. reacting too late to
                change?
            </p>
            <p>
                Consider software development like you're driving a stick. As you start, you're
                on first gear – coding away at a steady pace. The more you code, the less efficient
                you become. At some point, you have to shift up a gear.
            </p>
            <p>
                Shifting up a gear, in programming terms, is cleaning up your code &mdash; taking a step
                back to refactor, abstract, or implement a pattern. It means taking time to consider
                how to change your habits at a particular point in the development process. Doing
                this does not mean you've made a mistake (as some might argue). It's natural and
                necessary.
            </p>
            <p>
                You have to shift in code just as you have to when you're driving. But, if you do
                it too soon, you'll spend a lot of time trying to regain your speed. Do it too late
                (or not at all), and you're code will burn out. Knowing when to shift is essential.
                It keeps the development process running as efficiently as possible. You don't shift
                just to shift... you have to do it when it's right. You have to find your programming
                cadence.
            </p>
            <div class="cartoon">
                <img src="http://www.andertoons.com/img/cartoons/2418.jpg"/>
            </div>
            <p>
                There is no set amount of gears in software development. We can choose to have just
                5 or 500 gears in our programming cadence. This depends on the complexity and scale
                of the project as well as your own willingness to shift gears. For more complex projects,
                allowing yourself more gears means we can shift a lot more often. It means that if we shift
                a little too early, it won't take us too long to get back to speed. A little too
                late, and we haven't experienced too much burnout. For smaller ones, just a few
                gear shifts will do.
            </p>
            <h4>
                Develop your complexity nose</h4>
            <p>
                In the end, software complexity is necessary. It's the debt paid for more functionality.
                But, know when complexity feels right and when complexity feels wrong. Listen to
                your sixth sense when it tells you that, this time, complexity makes things worse
                on everyone. It's why what we do is much more art than it is science.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h2 id="teaching">
                Teaching</h2>
            <p>
                If there's anything I want you to take away from this book, it is to <em>learn</em>
                how to <em>teach</em>. Programmers who can teach well will become better programmers.
                That's why this is the most important chapter in the book.
            </p>
            <p>
                There are plenty of experts in the world, but far fewer great teachers. You can
                be a Rock Star programmer, but if you can't teach, you're suffocating your value
                in this business. Teaching isn't just <em>regurgitating</em> what you know. It's
                an art that requires you to step outside of your own knowledge and into the mind
                of someone who's learning something new. Simply knowing something is just one ingredient
                in the recipe for a successful teacher. Too often, we mistake someone with knowledge
                for someone who can teach.
            </p>
            <p>
                Isiah Thomas was a hall-of-fame point guard in the NBA. He was a 12-time NBA all-star
                and led the Detroit Pistons to two NBA championships as a player. As a head coach,
                he had a pedestrian record of 187 wins and 223 losses. Sometimes people with great
                knowledge and skill can't transfer those same traits over to the people they're
                trying to teach.
            </p>
            <p>
                Teaching programming concepts to a relative newbie is even that much harder. Learning
                to code just isn't as transparent as learning to play basketball, cook, write, or
                sing. It's overly cerebral. There are no obvious indicators whether someone is thinking
                about a software problem right or not.
            </p>
            <p>
                But every great programmer should work at becoming an equally astute teacher. It
                will help you work with passionate people and cultivate other future great programmers.
            </p>
            <p>
                Teaching also teaches you. The better you can explain to someone what reflection
                is, how and why you'd use an MVC framework in your web app, the differences between
                an abstract class and an interface, or when you should use a specific kind of SQL
                JOIN, the better you'll understand those concepts as well. Teaching makes you better
                at what you do.
            </p>
            <p>
                Let's first air the dirty laundry. Every one of us can be a better teacher than
                we are right now. We need to first recognize when we're not teaching at our best,
                and then figure out how to go about teaching better.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-41">
                #41: An expert coder doth not an expert teacher make</h3>
            <p>
                At first, it might seem like a great programmer should have the skills to be a great
                teacher.
            </p>
            <p>
                After all, coding has many of the same traits as teaching. Underneath the fancy
                patterns and elegant frameworks, code is just a set of concrete instructions to
                do something. Even if one, seemingly obvious, detail is left out, you'll know soon
                enough. Code has an order too. You can't implement a concept before it's been defined
                yet, just like you couldn't teach someone how to multiply before they understand
                how to add.
            </p>
            <p>
                On the other hand, the act of coding isn't like teaching at all. In fact, it promotes habits that are
                entirely counterproductive to the art of teaching. A really good programmer just
                might make for an awful teacher.
            </p>
            <p>
                First, rarely do coders code linearly. You don't start from the top of the page and just work your
                way down to the end. Along the way, a clear concept in your head turns
                into a half-truth. Part way through writing a method, you might decide you need
                to track things in an array. After a few minutes, you'll decide a hashtable works
                better. If coding against a platform is at all like talking to a student, you'd
                sound rather unsure of yourself.
            </p>
            <p>
                Second, coding lets you cheat on the details. We compile our code not because we
                think we're done, but because we want to find out what we may have missed. You can
                usually bucket most compiler errors in the "I was just being lazy" category. A missed
                instantiation here, a data-type mismatch or non-returned value there. I'm a habitual
                compiler. A compiler is a lazy programmer's best friend. Ditto for unit tests, code-hinting
                and auto-completion.
            </p>
            <p>
                All these niceties are great for programming. They give us softly padded walls to
                bounce our code off of. They let us focus on the hard stuff first and not worry
                too much about perfection in our code-speak. A good programming platform is simultaneously
                wiping our chin, correcting our grammar, and telling us what we really mean while
                we spew out semi-coherent lines of instruction. And, the faster and more efficient
                we are at coding, the more we rely on the platform to steer us in the right direction.
            </p>
            <p>
                Teaching a newbie is entirely different. Every missed detail is a lost detail. You
                can't start your sentences expecting your student to finish them — at least not
                early on. And unlike a compiler, who invariably will forget your missteps once you
                correct them, people don't have as much luck separating the wrong details from the
                right. You may compile your code a dozen times before you finally get it right,
                but imagine correcting yourself twelve times before your teaching lesson finally
                makes sense.
            </p>
            <p>
                An expert programmer does not make an expert teacher.
            </p>
            <p>
                How do you teach people well? It starts by knowing that what may make you a great
                programmer will not make you a great teacher.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-42">
                #42: Prevent the "Curse of Knowledge" from creeping into your teaching</h3>
            <p>
                In the popular Chip and Dan Heath book <em>Made to Stick</em>, the brothers argue
                that, once you've become an expert in a particular domain, it is nearly impossible to understand 
                what it feels like to not understand that domain. Think of how you might explain color
                to a person born without sight or sound to a person born without hearing. They call this the <em>Curse
                of Knowledge</em>.  
            </p>
            <p>
                In a less extreme example, think of a lawyer who can't give you a clear answer to a legal question without
                all sorts of abstractions and qualifications.
            </p>
            <div class="cartoon">
                <img src="http://www.andertoons.com/img/cartoons/4619.jpg"/>
            </div>            <p>
                Undoubtedly, one of the biggest abusers of the <em>Curse of Knowledge</em> is <em>us</em>. A great
                coder would have a hard time trying to imagine not knowing how to code. 
            </p>
            <p>
                That's also why teaching someone else your code after it's been through dozens of
                iterations is often difficult. It's a LIFO problem. Your knowledge
                of your code works from today backwards. You remember the last tweak and maybe even
                the one before that. But you've already forgotten the major overhaul that took place
                last month. And, you don't even remember what it looked like when you first threw
                it together. To you, the story of your code is like looking in the rear view mirror.
            </p>
            <p>
                And, that's what makes retelling the story of your code difficult. The person your
                teaching would best learn what you've written by experiencing it the way you did
                – from the start, going forward, up through this present moment.
            </p>
            <p>
                So, when you're teaching a newbie a seemingly basic concept, or taking your colleague through your
                own code, understand the <em>Curse of Knowledge</em> is in full effect.  Teach twice as slow as you think,
                explain the "obvious" details until it's crystal clear to your pupil.  
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-43">
                #43: Teach with obvious examples</h3>
            <p>
                 Good examples are devoid of abstractions. They
                are concrete and clearly &mdash; almost too obviously &mdash; convey the intentions of what you're teaching.
                They provide good <em>context</em>.
            </p>
            <p>
                For instance, imagine you're teaching a beginning programmer the basics 
                of object-oriented programming.  You might start, naturally, with object instantiation. You might decide
                this is a good example line of code to start the discussion:
            </p>
            <code>Object myObject = new Object(); </code>
            <p>
                For the already-acclimated, this is a ho-hum line of example code. It says, create
                an instance of an object of type <span class="code">Object</span>, called <span class="code">myObject</span>. It's known to us that
                the name <span class="code">myObject</span> is just any-old-name we decide to give this newly birthed instance.
                On the contrary, the constructor <span class="code">Object()</span> isn't just named in any old-fashioned
                way. It's the constructor &mdash; it has to be named exactly the same as the name of
                the class.
            </p>
            <p>
                But, to someone learning object instantiation for the first time, the line of code looks like this:
            </p>
            <code><strong><em>Object</em></strong> my<strong><em>Object</em></strong> = new <strong>
                <em>Object</em></strong>(); </code>
            <p>
                First impressions? <strong>Object</strong> is clearly significant. It shows up <em>three</em>
                times in one line of code! It's the name of the class,
                and, by rule, the name of the constructor. But, the embedded word <span class="code">Object</span> in <span class="code">myObject</span> has
                absolutely no significance. We just happen to call the instance <span class="code">myObject</span> for lack
                of a better name. But, for the newbie, its insignificance is <em>not</em> obvious.
            </p>
            <p>
                So, here's a better rewrite:
            </p>
            <code>Object mary = new Object(); </code>
            <p>
                Now, we're getting somewhere. <span class="code">Object</span> is still important, but it's clear that it
                has no implications on the name of the instance of the object.
            </p>
            <p>
                But, still, for a first-time object-oriented programmer, this is still a little
                too in-the-weeds. What kind of object is <span class="code">Object</span>? Back to the drawing board.
            </p>
            <code>Human mary = new Human(); </code>
            <p>
                Ah yes. Now, <span class="code">Human</span> is significant. The relationship between <span class="code">Human</span> and 
                <span class="code">mary</span> is intuitive,
                even for someone who doesn't write code for a living. It's a more palatable example
                of a class you could write. The newbie now envisions everything a human named Mary
                could do.
            </p>
            <p>
                But, there's still something hard to understand. If we already say "Human Mary,"
                isn't it obvious that she's a new <span class="code">Human</span>? What, exactly, is the point of a constructor?
            </p>
            <p>
                Here, a conundrum exists. Constructors that don't accept any parameters is fairly common. 
                For the seasoned developer, we're accustomed to working
                with classes that don't accept any parameters when instantiated. And so, the conventional
                <span class="code">new Object()</span> (or <span class="code">new Human()</span>, or <span class="code">new List&lt;DateTime&gt;()</span>) 
                feels intuitive. 
            </p>
            <p>
                To the newbie, it seems mindless. Constructors that don't accept parameters, and,
                even worse, don't do anything in its definition (aside from instantiating the object), baffle the OOP neophyte. So, if you want to ingratiate
                the masses that are looking up to you for help, make the example constructor accept
                a parameter (or two).  
            </p>
            <code>Human mary = new Human("female", 45); </code>
            <p>
                Ask the newbie if he can create another human named Doug, who just got his driver's
                license, and there's a good chance they can figure it out.
            </p>
            <p>
                The moral of the story? When showcasing examples, be <em>explicit</em>. Be more
                explicit than you think you have to be – we went through four iterations to get
                to a better example for something as basic as object instantiation. Cut out the generalities, generic names,
                and theory for something tangible and obvious.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-44">
                #44: In the beginning, go for blanket statements over the truth</h3>
            <p>
                When you teach something new, never start with the notion that everything you're going to say from here on out
                is 100% correct. Teaching a concept perfectly from the get-go is neither practical
                nor efficient. Any advanced concept is inherently difficult to understand. That's
                what makes it advanced. It's full of nuances, exceptions, and special cases that
                don't always fit into a nicely-wrapped unified theory.
            </p>
            <p>
                But, when you learn something new, that nicely-wrapped set of facts is exactly what you want. 
                We crave the hard and fast
                truths, whether they really exist or not, because they are the scaffolds that help
                you build your knowledge of any subject. 
            </p>
            <p>
                So, when you're the expert, let go of the intricate details of your domain at first.
                Let go of the "except when" and "but not if" cases – they just <em>aren't that important
                right now</em>. In the beginning, reveal the handful of rules that will get you most of the way 
                to understanding a concept well.
            </p>
            <p>
                When you pare down a complex topic into a less-than-perfect set of rules, it gives
                someone new a chance to build a solid foundation of understanding in their mind.
                When you teach subtleties and exceptions too early, before people have had a chance to soak in the
                general concepts, their learning becomes fragmented.  Piecing together the whole story at once becomes difficult. 
                It's hard to digest both rules and exceptions to those rules at the same time.
            </p>
            <p>
                And so what if the understanding isn't 100% correct immediately? A solid foundation
                of understanding is motivating. And motivation will get them to an advanced level
                <em>faster</em>.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-45">
                #45: Encourage autonomous thought</h3>
                <p>
                    Teach the "rules" in the beginning as if they were set by law:  Death by a thousand cuts if broken. It provides 
                    a structured starting point for a novice.  And, it's probably not a bad thing to instill a little fear...
                </p>
                <p>
                    This is also what the <em><a href="http://en.wikipedia.org/wiki/Dreyfus_model_of_skill_acquisition">Dreyfus model of skill acquisiton</a></em> preaches for novices as well.  The rules part of it, not the punishment part.  
                    The Dreyfus model is, put simply, a model of how students learn.  It was proposed in 1980 by a couple of PhD
                    brothers (Stuart and Hubert Dreyfus) in their research at UC Berkeley.  
                </p>
                <p>
                    According to the Dreyfuses, at the novice level, students follow rules without context.  There's no questioning.  
                    Why do you want to normalize a relational
                    database?  Why do you want complete separation of structure and presentation in your HTML markup?  Why do you want
                    to adhere to the DRY principle in software development?  Because that's what you've been taught, son.
                </p>
                <p>
                    But, when they start heading toward the expert level, those stone-etched laws are meant to be broken.  A proficient coder
                    treats those rules as guidelines &mdash; the orange plastic cones on the highway.  For instance,
                    there actually <em>is</em> a time and place to denormalize a database (e.g. when the database is a "read mostly" one, like
                    an <a href="http://en.wikipedia.org/wiki/OLAP_cube">OLAP cube</a>). But, a novice shouldn't know about the benefits
                    of denormalization in the beginning until she's fully grasped the benefits of normalization.  In order to understand
                    the cracks in the foundation, you need to intimately understand the foundation itself.
                </p>
                <p>
                    When you begin to master a subject like programming, you stop using rules to guide your work.  That
                    thing that just comes naturally, takes over.  There is no more recipe, there's just intuition.
                </p>
                <p>
                    And, that is what your student needs to know.  One day, on the road to becoming as good as <em>you</em>, your student has to cross that intersection where 
                    he questions the rules that you taught him in the first place.  One day, some of those beginner rules won't fit with, what
                    your student thinks is a better approach to the problem.  <em>Encourage that type of autonomous thought</em>.  
                </p>
                <p>
                    In Arthur J Riel's <em>Object-Oriented Design Heuristics</em>, a book of metrics for good object-oriented design, he states: 
                </p>
                <blockquote>
                    <p>
                        I refer to these 60 guidelines as "heuristics," or rules of thumb.  They are not hard and fast rules that must be 
                        followed under penalty of heresy.  Instead, they should be thought of as a series of warning bells that will ring when violated.  The warning
                        should be examined, and if warranted, a change should be enacted to remove the violation of the heuristic.  It is perfectly
                        valid to datte that the heuristic does not apply in a given example for one reason or another.  In fact, in many cases,
                        two heruistics will be at odds with one another in a particular area of an object-oriented design.  The developer is required to decide
                        which heuristic plays the more important role.
                    </p>
                </blockquote>
                <p>
                    In other words, break the rules when it makes sense to.  That's the big leap from novice to expert.
                </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h2 id="clients">
                Clients</h2>
            <p>
                In this business, clients, stakeholders, and customers are our lifeline. Without
                them, what we do amounts to nothing more than a hobby.
            </p>
            <p>
                But, quite often, the working relationship between us and them feels more like Ali
                v. Frazier than Penn and Teller. In an ideal world, our client is giving us backrubs
                and feeding us scoops of vanilla ice cream all while dabbing the corners of our
                mouths as we labor over their application. In an ideal world, the client knows the
                agony we sometimes go through to fit nascent ideas into real code.
            </p>
            <p>
                The harsh truth &mdash; clients rarely see what pains we go through to bend to changing
                requirements. Customers only think about that one new feature they want – the one
                that, in their eyes, involves "just changing this one little thing" when there's
                so much more too it. Stakeholders only care about the bottom line.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-46">
                #46: Difficult clients are not uniquely our problem</h3>
            <p>
                But, this problem is not uniquely ours. In fact, we have it easy compared to some
                others. 
            </p>
            <p>When an architect designs a house, the homeowner sees only what's easily
                visible. He sees the obvious qualities of the home – the granite countertops, hardwood
                floors, and crown molding – not the subtle nature of a floor plan that the architect
                may have anguished over for months.
            </p>
            <p>
                When a chef cooks a meal that's off by a salt grain, a picky critic delights in sending it back. 
                The chef's work, completely nullified, is tossed away. I once saw a rather pretentious family's
                entire set of orders sent back to the kitchen because their rather spoiled teenage
                son lost his appetite over a hairy bug in his meal. Gone was the work of an entire
                staff of laboring cooks because an ignorant client mistook a fibrous piece of ginger
                for a cockroach.
            </p>
            <p>
                We've all been the client at some point. Clients rarely appreciate the delicate,
                intricate, advanced thought that goes into the products they consume. And, perhaps that is 
                the cruel irony of it all. When I hire
                a plumber to fix the low water pressure in my shower, I simply want it fixed. I
                don't care if it's due to the main line, the flow constrictor or a clogged shower
                head. A cheap bill and some skin numbing showers will do just fine, thank you.
            </p>
            <p>
                In just the same way, when we build software for the consumer or client, the people
                we work with likely can't tell that you programmed the application with such elegance
                and cunningness.
            </p>
            <p>
                What does this mean? No one you work for <em>cares</em> about your code – at least
                not immediately. It also means that, when they want to change your software, they
                haven't the slightest clue whether that change in code is easy, hard, impossible,
                or annoying. They don't know if their one "would-be-nice-to-have" request is really
                a "would-be-awful-to-build" one as well.
            </p>
            <p>
                It's frustrating, yes.  But, don't pity yourself. You are not alone. 
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-47">
                #47: Teach clients what programming actually is</h3>
            <p>
                So how can we get clients to appreciate our labors more?
            </p>
            <p>
                Sometimes, it starts with teaching clients how we do what we do. This is especially
                true when you're working with someone that's never worked on their own web application
                before. Even the most completely obvious things to us are not common knowledge to everyone else. I've learned this lesson many
                times in my career.
            </p>
            <p>
                Years ago, I took on a freelance gig with a startup client who wanted to build a recommender
                system.  It would offer the cheapest prices on bulk liquor purchases for bars and
                restaurants. Sounded easy enough. I was 22, a relative programming newcomer, and
                naïve about how quickly complexity happens.  
            </p>
            <p>
                In my head, I envisioned I'd get a bunch of data &mdash; a list of alcohol brands, distributors, addresses,
                and costs. The user would request something, and I'd write some code that would go find
                the cheapest price in the system that fit the search parameters. My client and I met over coffee,
                 and went 
                our merry ways. He'd consolidate the data and I'd start building this rather <em>Simple, Elegant Example
                of Exquisitely Crafted Software</em>.
            </p>
            <p>
                A few days later, we met for lunch over an Excel spreadsheet. I opened it up, and
                it looked a bit hairy. It wasn't the simple 5 column table I was expecting. "Well, the prices 
                change based on how
                much quantity of the product you buy," my client said. There
                were two other columns &mdash; a maximum and minimum quantity of alcohol that had to 
                be purchased to obtain a specific price. 
             </p>
             <p> 
                Fair enough. After all, I thought, that is
                the whole point of bulk purchasing. Back to the drawing board for a few slight tweaks,
                and off we go.
            </p>
            <p>
                The following day, I had the solution. I added a couple of additional quantity range
                fields (<span class="code">BeginRange</span> and <span class="code">EndRange</span>) in my database. 
                The application would accept a
                quantity value and I could write a simple SQL query on the table where <span class="code">@quantity &gt;=
                BeginRange</span> and <span class="code">@quantity &lt;= EndRange</span>. It would then
                search the database based on these additional parameters as well. Newton, you've done it again! The system
                worked brilliantly.
            </p>
            <p>
                But, when we met again, my client looked puzzled. My code was beautiful, but there
                was something missing in the <em>behavior</em> of the system. As he played with
                the software, he noticed, there were a few more levers missing.
            </p>
            <p>
                As I would soon find out, in real life, you get discounts for coupling similar products
                together. The concept of bulk didn't just live per product, but buying <span class="code">X</span> amount
                of whiskey afforded you a discount on <span class="code">Y</span> amount of vermouth (Manhattan anyone?).
                And, the discounts differed based on how much whiskey you purchased. And, perhaps
                we ought to throw in a few free jugs of Maraschino cherries as well.
            </p>
            <p>
                From his end, the behavior of the system seemed off. In his experience, these deals,
                found by calling real human distributors directly, were commonplace. From my end,
                I didn't have the data to <em>deduce</em> any of this. And, even if we could get
                all the data I needed, I'd need a lot more time to figure out exactly how to organize it. Did I need
                to build some separate table of dependencies to handle discounted products based
                on the purchase of another product? Did I need to build a "common mixed drink" concept
                so the app could intuit what drinks you could make out of your purchases in order
                to offer other discounts?  Was there more madness I would find out after this?
            </p>
            <p>
                It dawned on me one day that I was not, in fact, building a concise, well-defined
                system to mine spreadsheets of data to harvest the singular, right answer. Instead,
                I was building Larry<sup>TM</sup>, the alcohol distribution manager. I was trying to account
                for decisions that were not easily deducible. Larry<sup>TM</sup> gives offers based on his
                relationship to his customer, his own 40 years of experience, and a general hunch
                or two. He knows what will drive customers back to his company as opposed to the
                other hundred distributors he competes with.
            </p>
            <p>
                Why wasn't I told all of this new information in the beginning?  Was he just hiding it from 
                my prying ears or did he just not figure it was important at the time?
            </p>
            <p>
                And here, in full daylight, arose the fundamental misconception that lots of non-techies have
                of software, and the web, and ones and zeroes. As web developers, we
                are primarily organizers of logic and information. Our jobs are mainly about pushing, pulling, 
                manipulating and displaying data.  Most of us aren't in the
                business of artificial intelligence. We can't easily write programs that recommend
                or guess. Even "recommending" or "guessing" is a product of some set of defined,
                describable logic.  Yet, sometimes, that's exactly how the outside world perceives this work &mdash;
                some kind of black magic.
            </p>
            <p>
                When I started to explain this difference to my client, he said he'd get back to
                me. Years later, my code is still sitting on my Dell Inspiron 2600 laptop &mdash; affectionately
                known as my <em>Dust 
                Collector / Paper Weight</em>.
            </p>
            <p>
                Looking back, the client-developer relationship became clearer to me. From my client's point of view, the web,
                software, databases – all these "technical" things were a foggy, mysterious haze
                of magic. There was some part of him that believed that code could magically take
                care of a few loose ends in logic, even if these small loose ends were the things
                that made this type of application really complex to build.
            </p>
            <p>
                In any project, there will be a certain amount of unknown.  This is the nature of our
                work. Rarely is an idea completely flushed out before we transition into development.
                And, even when everyone thinks it is, it really isn't. Weirdness has a way of dodging
                our minds when we're still talking about software; it tends to surreptitiously unveil
                itself only when we start building.
            </p>
            <p>
                Maybe that's why we build a love/hate relationship with our clients and customers.
                What is seemingly so obvious to those of us toiling "in the box" is sometimes lost
                to those on the outside. Because, it's in the box where the idea must finally be
                realized. It's in the box where you know, full well, whether you have something
                concrete or you don't. It's in the box where the real struggle occurs.
            </p>
            <p>
                That's why there's frustration from the outside as well. From their vantage
                point, they've thrown you lots of information and requirements and detail. Certainly,
                enough to get you started. They've let you know what they want, and they are waiting...
            </p>
            <div class="cartoon">
                <img src="http://www.andertoons.com/img/cartoons/4222.jpg"/>
            </div>
            <p>
                And, when, days or weeks or months later, they see something that isn't quite what
                they hoped for, they too are somewhat deflated. The box isn't as magical as they
                had thought.
            </p>
            <p>
                So, when these times arise, take your customer/client/stakeholder/user/dreamer into
                the box. Take them there early if need be. Show them what you've been working on.
                Step them through the actual code if you must. Get them involved in thinking through
                the questions that naturally come up to you when you're in the midst of programming.
            </p>
            <h4>
                Show them your kitchen</h4>
            <p>
                The box is our kitchen. When the customer is yelling at you, bring them in. Show
                them the line of piled up orders, the furiously busy staff, and the half-seared
                steak that fell on the floor. Explain to them why customizing their order isn't
                simple &mdash; that, even though we have ice cream and tomato basil soup, ice cream floating
                on top of hot soup simply doesn't work.
            </p>
            <p>
                You'd be amazed at the respect and admiration you'll gain from the people you're
                working for, when you let them peek at what's going on under the hood. A simple
                "idea," when manifested into an actual "thing," is full of little details that just
                never came up before the code arrived. The very details that you've now taken for granted, weeks into
                development, are still new to those around you.
            </p>
            <p>
                Get them in early so you can demystify what we do &mdash; it is not soothsaying, prophecy,
                or black magic. It is simply, programming.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-48">
                #48: Define the goals of your application, seriously.
            </h3>
            <p>
                Working with clients isn't easy.  The disconnect between you &mdash; programmer/designer/messiah &mdash;
                and them &mdash; unreasonable dictator-at-times, will always be there.
            </p>    
            <p>
                But, not all clients are difficult.  The better ones, the ones you want to keep for the entirety of your consulting
                career, the ones you hope will always have new projects and new ideas ready-to-serve you at a moment's notice,
                all seem to have one thing in common.
            </p>
            <p>
                Great clients put the <em>application</em> above themselves.  When the application is the <strong>most important 
                part of the project</strong>, everything falls into place.
                Each feature decision can be scrutinized by simply asking the question, "Does this make the application better?"  
                Feelings, both your's and the client's, aren't what dictate the outcome.  When the 
                product is not put at the forefront, clients will justify a feature request by other measures.  
            </p>
            <ul>
                <li>"...it's something cool I saw on another site."</li>
                <li>"...because it's 1996, and everyone's using <span class="code">&lt;blink&gt;</span> and a counter!"</li>
                <li>"...because it's 2005, and everyone's using RSS."</li>
                <li>"...because it's 2009, and everyone's got a Facebook and Twitter badge."</li>
                <li>"...because my usability book told me that content below the fold never gets read!"</li>
                <li>"...because our CEO loves pink!"</li>
            </ul> 
            <p>
                At the beginning of the client relationship, establish the goals of the application.  Decide, together, what
                the end-product is hoping to achieve &mdash; and write it down.  Doing this turns ammo like 
                "cool" and "cutting-edge" into blank bullets.  Establishing the goals lets you say "no" with more conviction.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-49">
                #49: Make your work interesting</h3>
            <p>
                One of the biggest misconceptions non-programmers have with programming is that it's mechanistic, algorithmic, downright
                robotic. But we know it's not. Programming is as much art as it is science. We are passionate about 
                our work in much the same way as artists, musicians,
                and chefs are passionate about theirs.
            </p>
            <p>
                It's our job to make our work <em>interesting</em> &mdash; to promote web development as a craft,
                not as mere wage work.  By doing so, you can change your relationship with your client.  It stops being just service
                work.  Engaging your client with work that's interesting will make them appreciate and respect your work more.  When
                your client respects you, they listen to you.  They place their trust in you.  They're more likely to give you the benefit of the doubt
                when your opinion differs from their's.
            </p>
            <p>
                How do people in other industries make their work interesting to
                the consumer?  It's easy to talk about 
                Jamie Oliver, the "Naked Chef" who has popularized British cuisine, healthy eating, and generally mashing everything
                together with your hands.  It's easy to talk about a musician like Jack White who, in Davis Guggenheim's rock guitar
                documentary, "It Might Get Loud," talks of his blood-stained guitars.  It's interesting because cooking and music
                tickle the senses, and people will listen to famous people talk about their craft.
            </p>
            <p>
                But, let me vouch for some lesser known names.
            </p>
            <p>
                Lou Manfredini is "Mr. Fix-It." He's an exuberant handyman who knows <em>everything</em> about fixing up a home.
                On his weekly Chicago radio show, he helps homeowners fix every type of problem.  Whether it's installing a new HVAC unit,
                combatting a leaky roof, or sealing a deck, Manfredini has a recommendation and opinion on everything.
                He's equally passionate about the type of paint you should use in your kid's room as he is about getting vermin out of your basement.
            </p>
            <p>
                Jeffrey Ruhalter is a 4th generation Master Butcher in Manhattan.  Watch him <a href="http://www.youtube.com/watch?v=kA7-KCBPvss">butcher a pig</a> 
                or <a href="http://www.youtube.com/watch?v=rQiFEhsmOCk">trim a piece of dry-aged steak</a>.  His eccentric style of communication
                oozes passion.  You can't help but find his work <em>interesting</em> &mdash; unless porterhouse ain't your thing.
            </p>
            <p>
                Manfredini and Ruhalter prove that you don't have to be in Hollywood to make your work interesting.  They are 
                heroes in otherwise unsexy vocations.  We can do the same.  Plus, I'd like to think programming merits more interest than leaky-sink fixing.  
            </p>
           
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-50">
                #50: Be forgiving and personable</h3>
            <p>
                Passionate programmers have a penchant for being irritable. Providing the absolute
                last line of defense between nascent idea and functional reality can be frustrating.
                The entire thought-chain prior to the code we write often lives in diagrams, functional
                specs, wireframes and the brains of those who claim to be the "idea guys." Yet,
                we're the ones faced with the daunting, often under-appreciated task of getting
                the damn thing to actually work. Bugs only live in code, never in napkin drawings.
            </p>
            <p>
                In years past, software was this unapproachable, often command-line driven thing
                that only geeks, dorks, and nerds used. It was built by even geekier geeks, dorkier
                dorks, and nerdier nerds. Back then, it may have been OK to play the stereotypical
                role of the anti-social, generally off-putting curmudgeon.
            </p>
            <p>
                But today, software is <em>everywhere</em> and it's for <em>everybody</em>. Our
                clients are everyday people, not just other software guys. They use the products
                of our labor like they use furniture. It's just there. The line between when someone's
                using software and when someone isn't is quite blurry. Our work is mainstream these
                days. It means we need to button-up how we work with the people we're building software
                for.
            </p>
            <p>
                And so, when one of our clients, one that isn't tuned into how we work, asks if
                they can just add another feature here that, in reality, breaks an already-agreed-upon
                assumption and undermines the entire architecture of your application, it's all
                too easy to quickly retaliate, feud, yell, or threaten.
            </p>
            <p>
                Instead, we need to be forgiving. Understand the view from above the hood while
                we're so entrenched in working under it. If a client's request isn't practical,
                explain to them why. Give them an example scenario that opens up that "whole new
                bag of worms." Offer an alternative solution to solve the problem they're having.
            </p>
            <p>
                And, make it a habit to talk to them in person.  Hear their real voice and let them hear yours. 
                Pick up the phone and call them instead of just emailing.
                You'll be surprised at how far a compassionate-sounding voice can go in getting
                things set your way.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h2 id="pride">
                Pride</h2>
            <p>
                The other day, I read an op-ed piece in the New York Times called "The Healing Power
                of Construction Work." In it, a carpenter from Middle America talks about how an
                unusual number of his hired construction workers were also in trouble with the law.
                Some of his best crafstmen were drug addicts, alcoholics, and felons.  Even a paroled
                murderer was in the mix.
            </p>
            <p>
                He wasn't suggesting that construction work attracted violent people; Instead,
                it provided some healing escape from their otherwise troubled lives.
            </p>
            <p>
                There is a calmness when you work with your hands, and a cerebral quality about using
                raw materials to build something. His hired hands didn't treat construction work
                as merely a job &mdash; it was an escape from reality and a chance to do something really
                <em>well</em>.
            </p>
            <p>
                Though, by all accounts, construction work is a blue-collar job, there is a primal
                reward to it &mdash; the satisfaction of creating something that didn't exist before.
                Construction is something that anyone physically able <em>can</em> do, if they learn, work
                hard, and care about the product.  Success gained even for those who otherwise have not found it
                in other areas of their lives.
            </p>
            <p>
                As I read the piece, it struck me that I approach programming in the same way. I
                am not a convicted felon, nor, do I personally know any fellow programmers who happen
                to be running from the law. But, I do know many that, whether they'd like to admit
                it or not, coding can be a soothing escape from reality. Programming gives you that same joy of
                building something out of nothing.
            </p>
            <p>
                Most programmers I know don't even care that much about <em>what</em> it is they
                build or who they're building it for. So long as they are solving an interesting
                problem and so long as there is an opportunity to build something elegantly. The
                mental exercise of dissecting a problem and solving it masterfully is the mental
                drug that keeps programmers addicted.
            </p>
            <p>
                We build and design software because, whether found near the surface, or buried
                deep into our souls, we actually <em>love</em> doing it. The best programmers I
                know toil over every small, sometimes insignificant, development decision. Because,
                just like those construction workers, it isn't just about writing code, it's about
                writing code <em>well</em>.
            </p>
            <p>
                Those who love this job aren't in it just for the money. There are easier ways to
                make money. This vocation was completely of our own choosing.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-52">
                We have a marketing problem</h3>
            <p>
                The problem? Few others outside our relatively small tribe realize how rewarding
                software development can be. Even many among us don't fully realize it. That's why
                I cringe when admitting I am a web-software-application-developer-guy. It all reeks
                of someone sufficiently intelligent, just settling for something. Perhaps, it has
                a lot to do with the nature of our work.
            </p>
            <p>
                At our worst, we are disgruntled and unhappy, hopping from one job to the next.
                It's no different than any other industry. But, the stigma comes because of how
                we exist when we're most passionate. As I mentioned, most of us don't care about
                what we're building, so long as we're <em>solving a challenging problem elegantly</em>.
            </p>
            <p>
                And to do just that, we live inside our heads a bit more than most. We stare at
                screens in a trance – typing, deleting, typing, and pondering in one seamless, delicate
                dance. We look out the window, seemingly longingly, when in reality, we aren't seeing
                anything but pseudo-code running through our heads. We are not smiling, talking
                or seeking any sort of reciprocation. We simply want to be left alone, to our own
                thoughts, as the world does whatever it does around us. This is the content, happy,
                passionate developer who's completely escaped the world around her.
            </p>
            <p>
                When we are least excited, we are also quiet. We aren't smiling, and we don't want
                to be talked to. The only difference is, we type with less vigor and look out the
                window <em>noticing</em> the world around us and wanting to get out. When encouraged,
                we will, in fact, sigh, bang a fist, and mutter how much we disagree with the work
                we are doing. The disgruntled software developer looks just like the most fulfilled
                one, just with a noticeable sigh.
            </p>
            <p>
                And so, we have a <em>marketing problem</em>. The rest of the world sees programmers
                as a breed of recluse, anti-social, unhappy headphone geeks rather than, what we
                really are – passionate craftsmen, thinkers, and game changers. Why is this?
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div class="content">
            <h3 id="lesson-53">
                Lessons from the cooking industry</h3>
            <p>
                Take the cooking industry. Emeril Lagasse, Bobby Flay, Mario Batali, and Gordon
                Ramsay are exuberant (sometimes annoyingly so) chefs whose passion oozes from their pores. Their passion reaches,
                not just other chefs, but the <em>masses</em>. Our (less famous) contemporaries
                don't have that same kind of global appeal. There are no programmer celebrities
                whose reach stretches beyond the engaged eyes of other programmers.
            </p>
            <p>
                At first, you may think it's because people generally want to cook more than they'd
                want to program. But, I can assure you that, while I routinely salivate when a chef
                prepares a <em>horseradish-crusted salmon with braised greens and smashed new potatoes</em>,
                I will not be making one for myself anytime soon. The cooking industry has found
                a way to sell its craft to everyone – even if many of us will never deglaze a pan
                in our lives.
            </p>
            <p>
                Maybe it's because we just like to eat. Food is visually stimulating. Watching someone
                prepare a meal stirs our most primal emotions. Some call it <em>food porn</em>.
                But, the modern-day buzz about food hasn't always been like this. After all, cooking
                shows have been around for decades. Most of us have heard of Julia Child, but ever
                hear of Justin Wilson, Jeff Smith, or Graham Kerr? They had their own cooking shows
                for years, but lived in a far less cooking-crazed society. They never gained the
                omnipresent appeal their modern-day contemporaries have today. What shifted?
            </p>
            <p>
                In the olden days, cooking shows felt like being in your grandmother's kitchen.
                A couple of cameras, some pedantic talk about a quarter cup of this and a teaspoon
                of that. Cooking shows were made for people who wanted to...<em>cook</em>. They
                never stretched farther beyond their audience. Cooking was just about cooking.
                Today's shows today slice from a completely different angle.
            </p>
            <p>
                First, they've emphasized the detail. There's the close-up shot, then the closer-up
                – the one where you can see the marbling of a thick slab of tenderloin while double-checking
                that the chef's fingernails are clean. HD television has helped the food industry,
                as much as any other industry, sell its stuff. In bygone days, a steak was just
                a steak. Now, it's about the intricate marbling, flowing juices, and grill marks.
                The <em>detail</em> is where the appeal lives.
            </p>
            <p>
                Second, today's shows make cooking approachable to everyone. Long-gone are the days
                where TV cooking was just about following a recipe. Today's shows emphasize simplicity.
                Everyone can do it. 30-minute meals, $5 dishes, and a good time with friends. Cooking
                is feasible and entertaining.
            </p>
            <p>
                Chefs play up their food like royalty. Passion lives in their description of ingredients
                and flavors, even if only using non-descript adjectives like "fresh," "flavorful,"
                or "zesty." Nowadays, chefs always taste their own food (usually at the climactic
                end of the show), exalting what magic it's doing to their tastebuds in sensationalized
                "mmms."
            </p>
            <p>
                Even further, <em>the bad stuff sells</em>. Go to a real restaurant kitchen on a
                Friday night and see the real story. Screaming, sweat, dropped food, and a general
                disaster-waiting-to-happen. <em>System D</em> in Anthony Bourdain's <em>The Nasty Bits</em>
                tells a far different story from the pristine world
                of cooking that's sometimes portrayed on television. And, it's a New York Times
                Bestseller.
            </p>
            <p>
                On TV, Gordon Ramsay has made infamous the state of affairs at many restaurants
                on their deathbeds. <em>Kitchen Nightmares</em> is the raw truth about how poorly
                a restaurant can operate, and still run. Watching a restaurant pull itself out of
                near-certain catastrophe is, apparently, <em>entertaining</em>. The cooking industry
                has learned how to sell their commodity to the masses.
            </p>
            <p>
                Other industry leaders have found the magic elixir as well. They present their craft
                in a way that tickles our senses enough to make someone who has no real interest
                in their craft, care.
            </p>
            <p>
                Don't agree? Just flip through your television on a weeknight. In the United
                States and Europe, there are wildly popular shows on crab catching ("Deadliest Catch"),
                dog training ("The Dog Whisperer"), children's choirs ("The Choir"), dieting ("The
                Biggest Loser"), babysitting ("Supernanny"), blue-collar dirty jobs ("Dirty Jobs"),
                and raising octuplets ("Jon and Kate Plus 8") . These aren't exactly glamour industries.
            </p>
            <div class="cartoon">
                <img src="http://www.andertoons.com/img/cartoons/4047.jpg"/>
            </div>
            <p>
                Then, why not software programming? Why can't we be among those that have figured
                out what makes their line of business marketable? Code lets us play games, make
                friends, converse with them from anywhere on this planet, find love, buy anything,
                monitor the sick, organize our lives, and everything in between. We create these magical
                tools <em>every day</em>. We have a captivating story to tell.
                Just ask the guy over there who's not saying a thing.
            </p>
            <p>
                I'm not suggesting <em>Top Programmer</em> or <em>Coding Nightmares </em>are in
                pilot production anytime soon. But, we ought to put ourselves out there with the
                masses. We build the tools that run today's society, and everyday, there are those
                among us figuring out how to build them faster, cheaper, and more beautifully than
                ever before. Programming is a fascinating job. It's up to us to show the rest of
                the world.
            </p>
            <p>
                The software world is, at its best, a beautifully run kitchen. At its worst, it's
                a complete organizational nightmare. <em>Legacy</em> usually means something grand
                and eternal in every other context besides what it means in software. We also live
                in a constantly changing medium. What we're using today will seem archaic five years
                from now. These are all viable topics for the masses.
            </p>
            <p>
                We need to do it in small steps. It starts with the way each 
                of us treats our work. At restaurants, good waiters take pride in presenting a dish.
                It's not just the chef's dish; it's his or her dish too. The craft, care, and art
                of it distinguish mere sustenance from exquisite cuisine. In the same sense, we
                ought to take pride in our work. Take off the headphones and talk to your neighbor,
                then talk to your wife, brother, sister, neighbor, and pet dog. Software development
                is full of craft, care and art.
            </p>
            <p>
                The process of building
                software can be interesting and entertaining. What we do <em>is</em> a marketable
                business. It's up to us to make it more than just about code, just as the cooking
                world has made their work more than just about ingredients. Absorb yourself in it.
                Then, write, speak, and teach it to others with passion.
            </p>
            <p>
                It's a struggle I have every day. Whenever I'm asked what I do for a living, I shrug.
            </p>
            <p>
                I want to say that I'm a web developer and designer &mdash; a modern day web programmer,
                if you will. But, "programmer" just doesn't have the ring I'm looking for. It lacks
                the chutzpah of doctor, architect, or President of the United States. "Doctor" means
                miracle worker, "architect" alludes to the dreamer and master builder, and I hear
                being President has a few perks as well.
            </p>
            <p>
                To the layperson, programmer equates to "working with computers," which carries
                about as much validity as equating a surgeon to "working with sharp things." The
                next time someone asks me what I do for a living, I'll tell them I'm a country music
                star. It's just easier.
            </p>
            <p>
                We are, in fact, sometimes doctors, architects, and rulers all at once. We work
                miracles with our code, dream, build, and lay down the law. This is the book I will
                give them when they ask me what I do.
            </p>
            <a href="#cover" class="chapter-link in-page-meta-link">Cover</a> <a href="#" class="prev-ch-btn in-page-meta-link">Top</a> <a href="#" class="next-ch-btn in-page-meta-link">Next</a>
        </div>
        <div id="copyright">
          Thanks for taking time out of your day to read my book.  I hope you enjoyed it! For updates, follow me on Twitter <a href="http://www.twitter.com/developerscode"  onclick="_gaq.push(['_trackEvent', 'Meta', 'Twitter Page (Footer Link)']);">@developerscode</a>
	 or on my <a href="http://www.facebook.com/developerscode" onclick="_gaq.push(['_trackEvent', 'Meta', 'Facebook Page (Footer Link)']);">Facebook page</a>.
	 <br /><br />All content copyright ©2011 Ka Wai Cheung. All rights reserved.  
        </div>
    </div>
    <script type="text/javascript" src="http://platform.twitter.com/widgets.js"></script>
    <script type="text/javascript" src="scripts/jquery-1.5.min.js"></script>
    <script type="text/javascript" src="scripts/jquery.scrollTo-min.js"></script>
    <script type="text/javascript" src="scripts/jquery.cookie.js"></script>
    
    <link href='http://fonts.googleapis.com/css?family=Permanent+Marker' rel='stylesheet' type='text/css'></link>
    <link href='http://fonts.googleapis.com/css?family=Copse' rel='stylesheet' type='text/css'></link>
    <script type="text/javascript">

        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-23123180-1']);
        _gaq.push(['_trackPageview']);

        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();

        $(document).ready(function() {

            var cur_rel = "";
            var cur_chapter = "";
            var seen_bookmark_note = false;

            if ($.browser.mozilla) {
                $(document).keypress(checkKey);
            } else {
                $(document).keydown(checkKey);
            }

            $(window).load(function() {
                $(".content").css("visibility", "visible");
                $("#copyright").css("visibility", "visible");
                $("#bookmark").css("visibility", "visible");
                $("#cover-return").css("visibility", "visible");
                $("#loader").css("display", "none");
                $('a[href^="http://"]').attr("target", "_blank");
                $("#bookdeal").css("visibility", "visible");
                setController();
            });

            $("#cover").css("height", 700);
            $("#cover").click(function() {
                scrollToChapter("#how");
            });

            $(window).resize(function() {
                setController();
            });


            markSelectedChapter("cover");

            $(window).scroll(function() {

                setController();

                var prev_chapter = cur_chapter;
                cur_chapter = "";

                var found = false;
                $("h2").each(function() {
                    if ($(window).scrollTop() >= $(this).offset().top - getCSSPx(".content", "margin-top") - getCSSPx(".content", "padding-top") - 1) {
                        cur_chapter = $(this).attr("id");
                        found = true;
                    }
                });

                if (!found) {
                    markSelectedChapter("cover");
                }
                if (prev_chapter != cur_chapter) {
                    markSelectedChapter(cur_chapter);
                }
            });

            if (bookmarkExists()) {
                showBookmark(parseInt($.cookie("bookmark-px")));
            }

            $("#bookmark").click(function() {
                killBookmark();
            });

            $(".btn-return").click(function() {
                $(window).scrollTo($.cookie("bookmark-px") - 50, 1000);
                return false;
            });

            $(".content").click(function(e) {
                var x = e.pageX - $(this).offset().left;
                if (x < 50 || x > 550) {
                    setBookmark(e.pageY);
                }
            });

            $("#next-pg-btn").click(function() {
                scrollDownPage();
                return false;
            });

            $("#prev-pg-btn").click(function() {
                scrollUpPage();
                return false;
            });

            $(".next-ch-btn").click(function() {
                var cur_y = $(window).scrollTop();
                var next_y = 0;

                $(".content").each(function() {

                    if ($(this).offset().top - getCSSPx(".content", "margin-top") > cur_y + 300) {
                        $(window).scrollTo($(this).offset().top - getCSSPx(".content", "margin-top"), 1000);
                        return false;
                    }
                });
                return false;
            });

            $(".prev-ch-btn").click(function() {
                var cur_y = $(window).scrollTop();
                var next_y = 0;

                $($(".content").get().reverse()).each(function() {

                    if ($(this).offset().top - getCSSPx(".content", "margin-top") < cur_y - 300) {
                        $(window).scrollTo($(this).offset().top - getCSSPx(".content", "margin-top"), 1000);
                        return false;
                    }
                });
                return false;
            });


            $("#main-toc a").click(function() {
                _gaq.push(['_trackEvent', 'Chapter', $(this).attr("href").replace("#", "")]);
                if (!isMobile()) {
                    tocClickEventHandler(this); return false;
                }
            });
            $("#toc a").click(function() {
                _gaq.push(['_trackEvent', 'Chapter', $(this).attr("href").replace("#", "")]);
                if (!isMobile()) {
                    tocClickEventHandler(this); return false;
                }
            });
            $("a.chapter-link").click(function() {
                _gaq.push(['_trackEvent', 'Chapter', $(this).attr("href").replace("#", "")]);
                if (!isMobile()) {
                    tocClickEventHandler(this); return false;
                }
            });


            function checkKey(e) {
                switch (e.keyCode) {
                    case 37:
                        scrollUpPage();
                        break;
                    case 39:
                        scrollDownPage();
                        break;
                }
            }

            function setController() {
                if ($(window).scrollTop() - $("#prev-controller").height() < 0) {
                    $("#prev-controller").fadeOut();
                }
                else {
                    $("#prev-controller").fadeIn();
                }

                $("#next-controller").css("top", $(window).height() - $("#next-controller").height() -
                getCSSPx("#next-controller", "padding-bottom") - getCSSPx("#next-controller", "padding-top"));

                if ($(window).scrollTop() > $("#lesson-53").offset().top - 300) {
                    $("#next-controller").fadeOut();
                }
                else {
                    $("#next-controller").fadeIn();
                }
            }

            function getCSSPx(selector, style) {
                return $(selector).first().css(style).substring(0, $(selector).css(style).length - 2);
            }

            function scrollUpPage() {
                $(window).scrollTo(Math.max(0, $(window).scrollTop() - $(window).height() + 10), 1000);
                return false;
            }

            function scrollDownPage() {
                $(window).scrollTo($(window).scrollTop() + $(window).height() - 10, 1000);
                return false;
            }

            function scrollToChapter(chapter) {
                var scroll;
                if (chapter == "#cover") {
                    scroll = 0;
                } else {
                    scroll = $(chapter).offset().top - getCSSPx(".content", "margin-top") - getCSSPx(".content", "padding-top");
                }
                $(window).scrollTo(scroll, 1000);
                return false;
            }

            function isMobile() {
                return (navigator && navigator.platform && navigator.platform.match(/^(iPad|iPod|iPhone)$/));
            }

            function showReturnBtns() {
                $("div#cover-return").css("display", "block");
                $(".btn-return").css("display", "inline");
            }

            function hideReturnBtns() {
                $("div#cover-return").css("display", "none");
                $(".btn-return").css("display", "none");
            }

            function showBookmark(pos) {
                showReturnBtns();
                $("#bookmark").css("top", pos);
                $("#bookmark").css("display", "none");
                $("#bookmark").fadeIn();
                seen_bookmark_note = true;
            }

            function hideBookmark() {
                hideReturnBtns();
                $("#bookmark").fadeOut();
            }

            function markSelectedChapter(href) {
                $("#toc a").removeClass("selected");
                if (href != "") {
                    if (href.indexOf("-") > 0) {
                        href = href.substring(0, href.indexOf("-"));
                    }
                    $("#toc a[href*='" + href + "']").addClass("selected");

                    if (!isMobile()) {
                        if (href != "cover" && seen_bookmark_note == false && $("#bookmark").css("display") == "none") {
                            $("#bookmark-note").fadeIn(1000);
                            seen_bookmark_note = true;
                        }
                        else if (href == "cover") {
                            $("#bookmark-note").fadeOut();
                        }
                    }
                }
            }

            function tocClickEventHandler(obj) {
                scrollToChapter($(obj).attr("href"));
                return false;
            }

            function setBookmark(pos) {
                _gaq.push(['_trackEvent', 'Bookmark', 'Set bookmark', 'Position', pos]);
                $.cookie("bookmark-px", pos, { expires: 14 });
                showBookmark(parseInt($.cookie("bookmark-px")));
                if (!isMobile()) {
                    $("#bookmark-note").fadeOut();
                }
            }

            function killBookmark(pos) {
                _gaq.push(['_trackEvent', 'Bookmark', 'Kill bookmark', 'Position', pos]);
                $.cookie("bookmark-px", null);
                hideBookmark();
            }

            function bookmarkExists() {
                if ($.cookie("bookmark-px") != null && $.cookie("bookmark-px") != 0) {
                    return true;
                }
                return false;
            }
        });
    
    </script>

</body>
</html>
